Thoughts, Monday Feb 8:
    * The game appears to be workable but needs some work.
    * First, it must be made more usable for human play through a terminal.
    * Secondly, we must create the capability to look at a game digitally, scanning along runs, and columns and such.
    TODO:
        * Add the ability to check if a given location has already been taken by a move(or what color it is)
        * Prevent players from placing moves where there already are some.
        * [DONE] Add ability to undo a move.
        * Add terminal interface to the game.
        * [DONE] Create a testing script that generates a game and runs through some moves.

Wednesday, Feb 10:
    TODO:
        * [DONE] Add ability to check if move is taken
        * [DONE]prevent players from making illegal moves
        * [DONE]Add automatic expansion of the game board
        * [DONE] add terminal interface
        * [DONE] Add handling of exceptions to terminal interface for situations like:
            * point off board
            * repeat point
            * non-int value
        * [] Update the demo notebook to showcase the game's capabilities
        * [FWD] Recognition of the game's end.
        * [] Tidy the repository, deleting random shit.
    POTENTIAL TODOS:
        * add scaling of the numbers to the size of the board so that how they look within the squares does not change.
        * add documentation to the code.
    On the expansion of the board:
        *[NOT DOING] It could be that the width and height of the board increases as neccessary and the aspect ratio is modified to maintain a square grid. This requires recognizing when a move is within n of the edge. Since most games usually approach one edge and not the opposite edge simulatenously, this would likely generate many squares that we don't even need.
        * [DONE] An alternative is to first redefine how the grid size is defined to not be inherently symmetrical across the x and y axes. This would allow us to expand just a single edge when needed and lead to better-looking games.
    How to recognize that a move is within two of the edge?:
        * The x (or y) coordinate would be more than the edge location-2. This could trigger the expansion of the boundary by one. 
        * The minimum distance to an edge can be calculated, and then that used to expand the border by n-spaces.
    On expanding the board:
        * Increasing the value for self.right_edge or any of the others would result in correctly drawing additional squares and gridlines. It would also increase the area in which moves are allowed. It would also modify the aspect ratio to maintain a square grid. The only missing piece seems to properly refresh the image displayed to the user.

Thursday, Feb 11:
    TODO:
        * [DONE] Transform game df data into matrix
        * [DONE] Scan columns and rows of matrix to fill queue
        * [DONE] Match patterns to queue contents to recognize end of game.
        * [DONE] Diagonal scanning
        * [DONE] incorporate end-of-game notice into playable game.
        * [] Consider different coordinate systems of game and matrices and its impact.
        * [DONE] Create helper functions for transforming game coordinates to matrix indices and vice versa.
        * [DONE] Come up with ways to mark board that makes it easier to place the move.
        
    THOUGHTS:
        * The next step seems to try and recognize patterns other than victory. Measuring and tracking soft and hard powers and threats could be a nice way to visualize a game.
        * It could be cool to have a mode where the recognized patterns are annotated directly on the plot. This would make debugging pattern detection much easier. Maybe just start with drawing a line over the winning series of moves. This could be done in a debug mode for starters. A notation that could be manually replicated owuld allow for comparison between us and the computer.
        * Adding methods like to_csv() and from_csv() would be good practice for other sitautions in which data is to be saved or loaded. It would also allow for the storage of games, making playing on the computer not imply that the game will be created and lost forever. These saved games would likely just be visualized, so some helper method for that would be good. Saving a game and playing it later would be good too; Maybe have a set number of games that can be saved, ask people for names to them, and display them like some sort of arcade game.

Friday, Feb 12:
    THOUGHTS:
        * It will be neccessary when working on pattern recognition to understand what is being recognized and where. Since it is not entirely clear even how we think about soft and hard powers and threats, the computer will certainly be a bit confused.
        * The terminology of soft and hard powers and threats is useful but may be insufficient. In the simple case of the eeexxeee arrangement, there is a single soft power and yet four possible, mutually-exclusive locations that would turn it into a soft threat. The terminology of soft and hard powers and threats refers to existing pieces and blanks, but does not talk about the locations where the new move would go.
        * New terms:
            *Soft Trigger: A location where, if a marker is placed, a soft power is transformed into a soft threat.
            *Hard Trigger: A location where, if a marker is placed, a hard power is trasnformed into a hard threat.
            
            Soft and Hard Triggers can coexist in a single tile, as is usually done to achieve a victory.
        
        
Saturday, Feb 13:
    THOUGHTS:
        * Could add step-through viewer for games, so that you can click the arrow keys to go forward and back. This would require a to_csv and from_csv-type methods that would allow saving and loading games. We would also need some sort of interface for interacting with the save files and displaying them. 
        * A library of games that allows you to step through them sounds pretty cool. Maybe even allow comments. Annotations should be optional to turn on or off. Stats displayed about the current slide and other slides as well, such as number of soft and hard power/threats for each player. Maybe a line graph where the past is filled-in and the future is alpha~=0.5.
        * The option to play a recorded game from a certain move is essential.
        * The ability to recognize similarities between games would be very cool. Might be difficult to recognize two games that are different but effectively identical, such as rotated games, transposed games, and reflected games. Games that were branches of other games should at least be recognizable as branches.
        * Add description of the game at launch, including victory condition and optional inputs
        * Maybe add an actual UI with buttons and shit.
        * It could be good to look into detecting key presses instaed of just text inputs.
        * Scaling the displayed numbers for the size of the grid could be nice.
        
        
Monday, Feb 15:
    THOUGHTS:
        * What are the benefits of tracking powers, threats, and triggers?:
            * The relative abosulte number of soft or hard powers between players might give an estimate of who is doing better.
            * The ratio of soft or hard powers to the number of moves made could give an estimate of how "tied up" or "free" someone's pieces are.
        * What are the benefits of tracking threats?:
            * The existence of a threat from the enemy is important to notice in order to properly react.
            * Unexpected victories usually come as a result of several moves which both trigger and generate power. The last move is usally in a location that is a trigger for multiple locations.
        * What are the benefits of tracking triggers?:
            * Two triggers in the same place indicate a location that will likely cause victory.
            * Triggers show us where we can go to force the enemy to make a move. Predicting where the enemy will go is already difficult for a person, and is inherently unpredictable.
        * What do we call the locations that you can place a move to prevent a threat from ending the game?
            * In the case of hard threats, there is usually only one place to go.
            * In the case of soft threats, there are usually a few options that allow you to block.
            * Any hard trigger is also an effective location for preventing a loss due to an enemy soft threat.
        * What metadata could each game have attached to it?
            * The names of the players and their colors
            * The name of the game itself. Could be autogenerated from the names and DateTime.
            * The date and time of the game.
        * What currently needs to be saved for a game?
            * The df
        * What needs to be recalculated after loading a game?
            * The location of the games edges
            * The game matrix
        
    TODO:
        * [DONE] Add Description of game at launch, including special character inputs
        * [DONE] Add to_csv, from_csv methods.
        * [DONE] Modify __init__ method to take an existing df.
        * [FWD] add detection of saved games
        * [DONE] add option to load a saved game or start a new one.
        * [FWD] Add comments to stuff
        * [] ? Add testing of loading and saving games
        * [FWD] implement autosave in case the game crashes.
        * [] option to save game image
        
        
    QUESTIONS:
        * Why does the use of exit() to end a game cause a SystemExit exception? Because that is literally all it is meant to do. The answer is to handle the exception at the highest level of your code, allowing you to gracefully exit from any point in your code. The use of os._exit(1) during the exception handling is an option to completely kill your program; in my experience seems to kill the kernel.
        
    IMPORTANT:
        * The game currently gets stuck trying to load a game after a save is performed. This could likely be helped by being able to check whether the specified filename is in the saves folder. If it is, then we can continue out of the input loop and simply load the game. This requires me to be able to list the contents of the saves folder.
        
Tuesday, Feb 16:
    TODO:
        * [DONE] Handle SystemExit exception
        * [DONE] add detection of saved games
        * [DONE] Fix issue of trying to load a game after playing a loaded game.
        * [DONE] Extract the selection of saves
        * [DONE] Create the game viewer.
        * [FWD] Add option to save and continue instead of just leaving

      
    * I think now that we have a viewer, it is a great time to implement the annotation for powers, threats, and triggers. The viewer (in a debug mode, potentially), will allow us to easily see how annotation generation is going.  
        
    Creating a step-through viewer for games:
        * Would be a third option alongside new game and loading.
        * Would load in a game as input
        * would listen to keyboard clicks for input
        * For each press, it essentially pretends that only a subset of the data exists and draws that.
        * A forward press increases the length of the data table
        * A backwards press reduces the length of the data table.
        * The enter key allows the user to start playing a new game from that point, with a double-check
        
    Should the viewer simply be built-in as part of playing a new or loaded game?:
        * Maybe later
        
    How to implement a viewer:
        * The game could have a view index which is normally set to "last" which determines location up to which information is displayed. For example, if a game that has gone for 10 moves has a view_index of 5, then retrieving the dataframe or displaying the markers will only show the first 5 moves. This would conflict with other properties, like the game board edges, which is something that gets calculated from the most recent DataFrame.
        * Passing the first n_rows of a game's dataframe into the game constructor would have the desired result. It then becomes a matter of keeping track of the index which we are interested in.
        
        
Wednesday, Feb 17:
    TODO:
        * [DONE] Add option to save and continue instead of just leaving
        * [DONE] Autosave
        * [DONE] Tell the user if a file already exists when saving
        * [DONE] Implement ability to play viewed game from the state that it is currently in.
        * [DONE] Replace some code with Input Handler for cleanliness
        * [DONE] Look into setting the size of the plot to be proportional to the number of squares in each dimension. This would prevent the displayed size of the pieces changing with the size of the board.
        * [DONE] simplify game loop
        * [PAUSED] choose some convention for how to count powers, threats, and triggers. 
        * [FWD] Add comments to stuff. Forces me to reinterpret and reevaluate existing code. 
        * [DONE] Adopt MITOCW testing framework
        * [FWD] Look into testing which involves interacting with the terminal.
        * [PAUSE] Allow '.' to separate move coordinates
        * [FWD] limit number of saves in saves folder.
        * [FWD] restructure scanning code
        * [DONE] Save completed games to records folder
        * [CANCELED] reorganize how different directions of scans have repeating code.
        * [DONE] compartmentalize the process of determining the save location, including asking about overwriting.
        * [FWD] Reassess categorization of class and static methods
        * [FWD] Add HP detection
        * [FWD] Add SP and HP visualization
        * [FWD] decide what to do about 'eefeffeee' being detected as a soft power with triggers in the -2 and -3 positions. Maybe check SP locations against HP locations to eliminate incorrect SPs. Maybe check for HPs first, and prevent creation of that SP.
        * [IGNORE] More-thoroughly test SP detection in different directions.
        * [DONE] Add calcaulation of powers and threats for games created from existing dfs.
        * [FWD] Create method that takes in a game and generates a game for each step in that game. The powers and threats in the game will then be aggregated and plotted.
        * [FWD]Add checking of ST and HT lists during creation of SPs and HPs. What about checking for HTs during ST generation? To do that, we would need to loop through the queue's yet again. We must also make sure that SPs are superceded by HPs. We need to loop through the queues 4 times to check for, in this order, HTs, STs, HPs, SPs, with each subsequent group checking if any match's markers are a subset of a match from a higher-order group.
    
    THOUGHTS:
        * There are still many things to clear up about how to store information about strong and weak powers, threats, triggers. These must be worked out on paper before any digitization makes sense.
        * I am getting to a point in the decision tree of my main game loop that some diverging paths converge again. The simplest solution to me seems to package any locations where paths converge as its own function, and just use that in both places in the tree. This could result in many unimportant functions, but it's all I got.
        * I process many simple inputs from the user, and it takes up a lot of lines of code with its while loop and shit like that. Maybe I can create some general input handler for simple cases.
        * There is an issue with double-counting sets of markers as both threats and powers. The solution i will try is to calculate threats first. If a power is detected and all of its markers belong to a single threat, then that will not be considered a power. This would prevent 'eefeffeee' from being considered both a SP and ST, which is good. This would also prevent 'eefffee' from being considered a hard power, which i am unsure about. We'll see.
        
    SIMPLE INPUT HANDLER:
        * A common case for handling inputs is a many-to-few case, where the user can input anything from a few lists. Any input that is included in any of the lists will case the output of a flag value indicating which bin was satisfied. Failure to provide a response within any of the categories elicits a prompt to the user. The flag value is used downstream of the input handling to determine what actions are performed. Since the performed actions can be quite complex and involve any variables from outside the input-handling context, the performed actions will not be supplied as inputs to the input handler.
        CASES THAT ARE NOT EASILY-COVERED:
            *When the input is checked for special values, and if all of those checks fail, the input is passed onwards.
            * When complex input verification is necessary, like whether something is an integer or passes a certain function. I suppose that the valid list of options for each output possibility could be replaced with a function that takes the user-supplied-input and returns True or False. The input_handler could check whether it was supplied a list or a function.
            * We currently check if the user input falls into a category. It also nice to check if some constant is contained within the user input, like a '.'
        
    REMINDER:
        * Just added processing of SP patterns. Not tested.
        * Next is to compare these patterns to the scanned queues and add the results some list of powers and triggers
        * The scanning will lkely need to be modified to reduce the repetition of code.
        * 
        
    
        LESSON: Hide as much input handling code as possibled. What we care about is the final decision, no matter how circuituous the path. Example, FIAR.save_name_input().
        
    STATIC vs CLASS METHODS:
        * Static methods should not modify the class object if they are handed one.
        * 
    
    Thoughts on combining the different scanning methods:
        * Each scanning method can be defined as a set of starting points from which you go a certain distance in a certain direction. This direction is the opposite of the tail direction, which we need to calculate marker and trigger locations when pattern matches are found.
    
    Thoughts on heirarchy of recognition for powers and threats:
        * One way to prevent double-counting of markers as soft and hard powers and threats is to loop through the queues 4 times.
        * Another way is to first generate all of the different powers and threats, only making sure that any equals within the groups are lumped together. Then we can systematically step through all of the STs and compare them to HTs. Then compare all of the HPs to the HTs and STs. Then compare all of the SPs to the HTs, STs, and HPs. This eliminates the need to loop 4 times through the queues.
Saturday, Feb 20th:
    TODO:
        * Reorganize code to allow for better scanning
        
    THOUGHTS:
        * It could be useful to look at the section in the Python Cookbook on data processing pipelines, since that is essentially what I am trying to do.
    THOUGHTS on Restructuring of scanning:
        * Parts:
            * Generate list of starting points for each scanning method
            * For each set of starting points, build your queues in a certain direction.
            * Perhaps this code spills out queues, their head locations, and tail directions.
            * These queues are scanned for powers and threats and recorded
            * The lists of powers and threats are scanned through again and collapsed within their individual categories. This would be most efficient in the context of a particular scanning direction.
            * The powers and threats are examined in heirarchical order to eliminate double-counts.
            
        * Do we need both a queue of len6 and queue of len5?
            * queue5 will always be the front 5 elements of queue6. The receiver of queues from queue_scan could just make queue5 on the spot.
        
        * If the code matching patterns to queues isn't concerned with overlapping powers then does it need to know the head_loc and tail_dir? I think not. it can just return a matching pattern.
            
    LESSON:
        * If you think the problem ahead is a bit unclear, even if you aren't willing to admit that it will be "hard", start with the documentation for individual functions. This will verify if the pieces as you imagine them fit together, clarify your goals when you are actually writing code, and is something that you'll have to do at some point anyway. If you wait to document until after you've written your code, you will find holes in your code that would not otherwise have been there, and you will not remember what everything does. Writing code in un-spec'd functions is a great way to muddy the scope of a function and to start writing unmodular code.
        * Always create your testing framework before coding anything. It is your eyes, and without it you are blind.


Tuesday, Feb 23:
    TODO:
        * 
        
    THOUGHTS:
        * There are likely many places where the use of generators would be beneficial.
        * I have hidden away the ugly generation of queues, but now I want access to the moments at which we switch rows to clear some memory. I could capture the switch from one row to another in the values that are returned by queues(), such as by structuring the queues in a nested data structure where it goes direction[starting_loc[queues[]]]
        
    SCANNING:
        * generate list of lists of lists of queues
        * unpack list of lists of lists of queues while matching patterns
        * Matched patterns for each category are compared heirarchically and repeats eliminated.
        
    We either go through all queues 4 times in order of the heirarchy of powers/threats and compare all new matches with the existsing ones in the same line of scanning OR we go through the queues once, generating overlapping powers and threats, and then clean them up later. It would be difficult to clean up the matches and eliminate repeated ones without knowing which pattern matches line up with each other.
    
    We could have a master list of PoTs. Each category of power or threat is run through and compared/added to the master list. Repeats are eliminated.
    
    PROBLEM:
        * By nesting my queues within their respective contexts of scanning direction and starting location, i was forced to generate a list of all the queues, which is very memory-intensive. Modifying the queue_gen to generate queues on demand but still in a layered format would be excellent, though potentially difficult. Could use some tips from the pipeline example.
        
Wednesday, Feb 24:
    TODO:
        * [DONE] Complete detection of all powers and threats
        * [DONE] Visualize Hard and soft powers and add it to the viewer
        * [] Reintroduce ending the game upon victory
        * [DONE] Add option to view record games
        * [DONE] Add some nice formatting to the terminal interface
        * [FWD] Switch to the viewer once a game has been completed
        * [FWD] Properly handle key.char lacking attributeError
    MAYBE TODO:
        * Make visualization of hard and soft powers toggleable
        * Store PoTs in a df.
        * Create some tests for PoT detection.
        * Extracting and plot PoTs for a game over time. Maybe lines
        * Generalize marker plotting function to draw both numbers and PoT markers
    DRAWING PoTs:
        Soft Powers:
            * Draw marker on trigger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Hard Powers:
            * Draw marker on triger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Soft Threats: 
            * Find any gaps between marker locations
            * Shade marker locations and gaps in grey or red
        Hard Threats:
            * Find any gaps between marker locations
            * Shade marker locations in darker grey or red.
            
    THOUGHTS:
        * We may want to not have Soft Threats eliminate overlapping hardpowers when detecting PoTs. This could be achieved by cmparing STs and HPs to the HTs list independenty, and then combinging all three. SPs would then have to be compared to the combined list and added.

Thursday, Feb 25:
    BACKUP TIME LOG:
        11:05-11:45
        11:55-12:55
        13:10-
    TODO:
        * [FWD] Properly handle key.char lacking attributeError
        * [DONE] Switch to the viewer once a game has been completed 
        * [DONE] Reintroduce ending the game upon victory
        * [DONE] If "None" provided for save name, no save made
        * [DONE] Implement SPotential
        * [DONE] Implement Defusers
        * [FWD] Create method that takes in a df and generates a df for each step in that game. Another functions wraps that and returns a game for each step instead.
        * [FWD] create some way to visualize SPots for debugging
        
    TODO CANDIDATES:
        * [FWD] Add way to extract summary statistics on a game and display them
        * [FWD] Add option to have PoT overlay on during regular gameplay
        * [FWD] Add way to judge the quality of a move
        
        * [FWD] Make the named tuples in which threats are stored have the opposite of trigger_locs, locations that defuse the threat. This could dramatically streamline decision-making for a player facing a threat. These locations could even be part of the overlay. 
        * [FWD] Add the drawing of defusers to the overlay. Maybe as a bold(for HTs) box around the defuser.
        * [FWD] Create a function for determining the Possible Play Space(PPS) for a particular player.
        * [FWD] Create a separate viewer class to store the viewer_index and improve compartmentalization. 
        
    PUT OFF:
        * [NEED INTERNET] Investigate the "AttributeError: module 'FIAR' has no attribute 'FIAR'" problem
        * [FWD] Create a separate type for each pattern, so that we don't rely on matching the first two letters of the name, and all instances of "Spots" can become "SPots".
        * [FWD] Indicate in the viewer what step you are at.
        * [FWD] Investigate the creation of too many figures when drawing markers.
        * [FWD] limit number of saves in saves folder.
        * [FWD] Add comments to stuff, especially inputs and outputs of functions and their types.
        * [FWD] Reassess categorization of class and static methods
        * [FWD] Look into testing which interacts with the terminal.
    
    BUGS:
        * [DONE] "Black victory detected" when last move made in viewer
        * [DONE] You can load a game that has already been won, have it ask for a move, and then say the game is over after the move is made no matter what. Instead, it would be preferrable if a game is checked for victory upon loading
        * [IGNORE] When you load a game that has been won already, the victory is immediately noticed and play ceases, but the user is still asked if they would like to save it. Whatever; they can just not save it if they like.
        * [] in games where there is a victory, the Viewer can misidentify it as a Hard THREAT.
    
    IMPLEMENTING SPOTENTIAL(SPots):
        TODO:
            * [DONE] Define a set of patterns which we are looking for.
            * [DONE] Mirror PoT implementation to spread SPots throughout the code.
                * [DONE] RAW pattern processing
            * [IGNORED] List SPots separately
            
            
    IMPLEMENTING DEFUSERS:
        TODO:
            * [DONE] Redefine STs and HTs to have their own NamedTuple, and debug that
                [DONE] changed Nmedtuple "name" to "names"
                [DONE] add defuser 'd's to the RAW patterns.
                [DONE] 'd' in pattern processing
                [DONE] have collapse_PoTs accept different threats without a "trigger_locs" property. Don't need to combine defusers from different threats, since they are never subsets of each other.
                [DONE] Have visualization work with different Types of PoTs
            * [DONE] Populate the defuser fields during PoT detection
            * [DONE] Add defuser visualization in the overlay.
    
    COLLAPSING SPots: (YES)
        *PoTs are collapsed by combining PoTs that share the same markers. Does this work for SPots? I think so
    
    OUTPUT of PROCESSING A GAME: 
        * All PoTs
        * Number of PoTs for each player
        * Whether a player has two simultaneous threats with different defuser locations
        * 
        
    JUDGING A MOVE: (PAUSED)
        * Individual moves can be good but bad within the larger context. For this reason, some understanding of the current state of the game is neccessary.
        * Numerically judging whether a move is decent becuase it creates or eliminates powers is very possible. However, we often make constrained moves depending on what threats and powers we and our enemy have.
        REALISTICALLY:
            * Evaluate each tile as a weighed sum of addition or removal of PoTs to self or enemy, respectively.
            * Calculate balance of power by comparing total number of PoTs for each player.
            * Modify relative value of adding or subtracting PoTs depending on relative balance of power.
        LIKELY IMPOSSIBLE:
            CONCENTRATIONS OF PoTs:
                * One should be less afraid of enemy powers that are separate that those are close together. 
                * Could try some sort of "nearest-neighbor" stuff to identify clusters. Maybe have a maximum distance from the cluster center beyond which powers don't count.
                * Inclined to track concentrations of triggers, since those are the locations where pieces would be placed and the game would "happen". 
                * Tracking the marker locations might not recognize a confluence of triggers from different directions.
                * A concentration of Pots would have values for location, total_span, total_strength, density, and maybe more.         
            SEVERAL MOVES AHEAD:
                * It is often the case that by spending hard powers and effectively choosing where your opponent goes that you can think several moves ahead with absolute certainty. Being able to think several moves ahead would allow a computer to individually rate each of those successive moves and decide that it's a good idea.
            RECOGNIZE FORCING ENEMY MOVES
                Even if the computer does not plan more than one of its moves in a row, it could at least recognize that triggering a hard power means choosing where the opponent goes, and try to evaluate the "goodness" of that spot for the enemy; you wouldn't want to force your opponent to win, for example, even if you'd gain a bunch of soft power. Though one could easily judge that using a hard power which forces the opponent to win is a bad idea, it would be harder to compare two non-game-ending moves where one
        CONDITIONAL-CONSTRAINT LOGIC_ROUGH:
            STEP-BY-STEP:
                    Tile Evaluator    
                        * Possible Play Space (PPS) are defined by all tiles within a certain distance of already-played pieces.(Maybe just the whole board, since it scales)
                        * If there is a hard threat against me:
                            * PPS of one location: the defuser of the HT.
                        * Elif there is a soft threat against me:
                            * PPS is the union of enemy ST defusers and your own HP triggers
                        * Evaluate entire PPS through some formula
                    AI:
                        * Run Tile Evaluator
                        * Pick the location with the maximum value
                        * Place a move there.
                    Advisor:
                        * Run Tile Evaluator
                        * Pick top three moves and draw them on the overlay
                        
                        
    NEW TERMINOLOGY: (YES)
        * Defuser: A location which if a player was to go there, would cause an enemy threat to stop existing. Inverse of a trigger.
    
    Terminal Interface Testing: (YES)
        * Instead of being listened to, the keyboard can be emulated, and this can allow us to test the terminal interface.
        
    SPotential (SP predeccesors): (COVERED)
        * It could be useful to track the predeccessors to SPs. 
        * Their number indicates a player's ability to create SPs, which is important. Qualitatively, this would reflect how constrained your markers are.
        * This will be called SPotential, because that's a great name.
        * Tracking SPotential and it's triggers would allow us to judge whether a move would add or subtract soft power.
        * SPotential would likely not be displayed on the overlay, because it would create too much clutter.
    
    WHAT ARE THREATS ANYWAY?:(ANSWERED)
        * A hard threat is something that unless you defuse it wil make you lose the game in one turn.
        * A soft threat is something that unless you defuse it or use a hard power will make you lose the game in two turns.
        Is the intersection of triggers from two soft powers a threat?
            Conclusion:
                * Because it is possible to ignore a tile with ovelapping triggers from two soft powers and not be guaranteed to lose the game, this situation is not to be considered a "threat"
                * Because this tile with overlapping triggers from two soft powers is still quite dangerous, this should be reflected in the equation that rates moves. This could be treated as a special case, "A tile with two different enemy triggers", or come naturally, "Moving here will simultaneously reduce the enemy's total soft power count by two.
            Reasoning:
                * It is certainly dangerous, and I would prioritize that spot highly whether it was my move or the enemy's.
                * If ignored, the enemy could trigger both soft powers simultaneously
                * It is possible to prevent defeat at this point if you can simulatenously defuse on of the soft threats and create your own hard threat
                * As long as the defuser for your hard threat isn't also a trigger for an enemy power, you could then defuse the second enemy threat and not be "threatened".
   
   POWER vs SPotential: (COVERED)
    * POWER the ability to create a threat with a single move.
    * SPotential is the ability to create a soft power with a single move.
    * Neither influences the enemy's move very much, and so both of their importance is derived from the fact that they can eventually createa a threat. As such, it seems that they should essentially be treated as unequals from the same category.
    * Should SPotential be eliminated if its markers overlap with that of an existing power or threat?
        * If the lines along which they are looking are different, no.
        * If the lines along which they are looking are the same, maybe. We could implement that easily-enough if need be.

Friday, February 26:
    TODO POTENTIALLY:
        * [FWD] Add legend to viewer for PoTs
        * [FWD] add a forfeit option
        
    * Maybe put 0,0 move automatically?
    * When rating a move, rate moves for your opponent and see if there is a really good spot that they might want. This would mostly be spots that generate soft powers, since anything higher-order would show up as powers or threats.
    
    BUGS:
        * opened a completed game in the viewer when asked. Stepped around, and eventually tried to continue from a previous point. Immedaitely got an improper victory message and was asked to save. Happens even if you restart kernel and open viewer again.

Monday, March 1:
7:30 - 9:05 (1:35)
9:55 - 11:25 (1:30)
11:35 - 15:20 (3:45)
16:40 - 18:50 (2:10)
19:15 - 19:40 (0:25)
19:50 - 20:40 (0:50)

    TODO:
        * [IGNORED] Restructure Viewer as separate class that holds its own value for the view index
        * [DONE] Move the victory pattern recognition to somewhere that the viewer won't trigger.
        * [DONE] Reset victory flag properly.
        * [DONE] Properly handle key.char lacking attributeError
        * [DONE] Create method that takes in a df and generates a df for each step in that game. Another functions wraps that and returns a game for each step instead.
        * [DONE] create some way to visualize SPots for debugging
        * [DONE] Create a function for determining the Possible Play Space(PPS) for a particular player.
        * [DONE] Add option to have PoT overlay on during regular gameplay
        * [DONE] Add HPots to the game.
        * [DONE] Add defuser locations to Soft Powers for AI
        * [DONE] Add defuser locations to Hard Powers for AI
        * [DONE] Generate a dict of Cells that contain information on PoTs
        
    TODO CANDIDATES:
        * [] Add way to extract summary statistics on a game
        * [] add way to extract summary statistics on the entire history of a game
        * [] Add way to display summary statistic on a game
        * [] Add way to judge the quality of a move
        * [IGNORED] Create a separate viewer class to store the viewer_index and improve compartmentalization. 
        * [] Add choice of whether to play 2 player or against a computer
        
    PUT OFF:
        * [NEED INTERNET] Investigate the "AttributeError: module 'FIAR' has no attribute 'FIAR'" problem
        * [] Create a separate type for each pattern, so that we don't rely on matching the first two letters of the name, and all instances of "Spots" can become "SPots".
        * [] Indicate in the viewer what step you are at.
        * [] Investigate the creation of too many figures when drawing markers.
        * [] limit number of saves in saves folder.
        * [] Add comments to stuff, especially inputs and outputs of functions and their types.
        * [] Reassess categorization of class and static methods
        * [] Look into testing which interacts with the terminal.
    
    BUGS:
        * [IGNORE] When you load a game that has been won already, the victory is immediately noticed and play ceases, but the user is still asked if they would like to save it. Whatever; they can just not save it if they like.
        * [] in games where there is a victory, the Viewer can misidentify it as a Hard THREAT.   
        
    ITERATING THROUGH GAMES: (SOLVED)
        * To step through each state of a game, it would be nice to first step through every state of a df and wrap that.
        * If we only needed to iterate through the games, then I could add an iterator protocol to the FIAR class. That might actually still be the best move; using a DF iterator within it might be possible.
        
    VIEWER OBSERVATIONS: (DONE)
        * When the overlay is turned on and off, the "Powers and Threats" are reprinted. This may indicate that they are being recalculate unneccessarily as well.
    
    THOUGHTS:
        * it might be interesting to differentiate between games and views of games.
        
    DETERMINING THE PPS (DONE):
        * Possible Play Space (PPS) are defined by all tiles within a certain distance of already-played pieces.(Maybe just the whole board, since it scales)
            * If there is a hard threat against me:
                * PPS of one location: the defuser of the HT.
            * Elif there is a soft threat against me:
                * PPS is the union of enemy ST defusers and your own HP triggers
            * Evaluate entire PPS through some formula
            
    ROADMAP TO AI:
        * There is a list of properties for each cell that is relevant to the decision-making process of the current player
        * Given a game: 
            * a dict of cells is created of the appropriate size
            * All the PoTs, SPots, and HPots are cycled through and their relevant locations are added to the cells' properties.
        * If we create a dict of cell objects, each with all the relevant properties:
            * we can scan through all SPots and PoTs and add their triggers and defusers to the relevant cell
            * we can then iterate through all of the cells with PPS and apply a formula to them. The largest number is the best move
        * The best move is then made by the computer.
        * PROPERTIES NEEDED FOR FIRST VERSION OF AI:
            * GAME-WIDE:
                * 
            * CELL-SPECIFIC:
                * The location of the cell
                GOOD FOR SELF:
                    * if there is a friendly Hard Threat defuser (a winning move)
                    * If there is a friendly Soft Threat defuser that would lead to victory (NOT IMPLEMENTED)
                    * number of friendly SPot triggers (number of soft powers generated by moving there)
                    * number of friendly boosters (number of hard powers generated by moving there)
                    * number of SP triggers (number of STs that would be created)
                    * number of HP triggers (number of HTs that would be created)
                    * 
                BAD FOR OPPONENT:
                    * number of enemy hard threat defusers (defuse a hard threat to not lose the game)
                    * number of enemy soft threat defusers (defuse a soft threat to not lose the game)
                    * number of enemy soft power defusers (number of soft powers removed from enemy)
                    * number of hard power defusers (number of hard powers removed from enemy)
                    * 
        * PROPERTIES POTENTIAL FOR FUTURE VERSIONS OF AI:
            * GAME-WIDE:
                * Ratio of all own powers to enemy powers. (Determines how important it is to bolster self or weaken enemy).
            * CELL-SPECIFIC:
                * number of empty tiles around the tile
                * Whether it is on-grid with other markers of yours nearby
                * How many enemy neighbors it has. A measure of freedom.
                
    HARD POWER PREDECCESORS: (DONE)
        * It would be useful to know if moving on a location would generate a hard power.
        * Any friendly move in a soft power which does not generate a soft threat will generate a hard power.
        * Hard-power generating locations are currently denoted with 'e' in the raw patterns or '+' in the matching patterns. During pattern processing, we could add another category, booster_locs, which hold these other locations.
        * What to call them?:
            * They generate hard powers
            * Erectors?
            * Harder_locs?
            * Harden?
            * Empower_locs?
            * booster
        * Are there non-SP predeccesors to HPs that we are not considering?
            * YES, sadly. Since HPs patterns are only 5 long and SPs are 6 long, there are plenty of HP predeccesors which are not themselves soft powers.
            * We can create a group called HPots, which are predeccesors of hard powers. These will be recognized like any other pattern and saved. There relationship to SPs could be:
                1. (CHOSEN) Subordinate to SPs. Any HPot that shares all of its markers with an SP is considered to not exist, and a tile in that SP leading to a HP will be a booster. Any HPot which is not an SP will exist, and it will also have boosters that indicate whether a move will create a hard power. CHOSEN
                2. Indepenent of SPs. All HPots exist, even if they share markers with SPs. This means that SPs will not have boosters, and that all hard power-generating tiles will be boosters or triggers in HPots. This also means that SPs and HPots will be double-counted, and it will not be clear from an HPot whether it is part of an SP or not.

    INFERRING THE CONSEQUENCES VS SEEING THEM:
    Conclusion: 
        We will go with the inferrential approach, because it allows us to make decisions without having to simulate a bunch of moves. Additionally, we've been able to answer all the questions that we've come up with using the inferrential approach. If we ever try to think n-moves ahead, the clarity of vision that the inferrential approach provides is much superior to the O^n complexity that the brute force approach has.    
    Broadly, we have two approaches before us:
        INFERRING CONSEQUENCES:
            Refers to the process of analyzing points on the map as triggers or defusers of powers or threats, and then deciding which is most important.
            * This approach seems more elegant, but requires more upfront work to notive every possible change that a move might cause. It becomes quite subtle when we start talking about adding or removing different types of powers. If we ever reach a situation in which we cannot recognize a certain consequence without brute force, then we will be forced to resort to the brute-force method.
        SEEING CONSEQUENCES:
            Refers to the brute force approach of considering the possibility of moving onto any given square and then seeing how the number of powers and threats has changed.
                * This approach is much more computationally expensive, and may even approach being prohibitive, since each possible move generates a new board which is then fully scanned through.
            
    NECCESSARY BEHAVIORS OF THE AI:
        * If a friendly soft threat remains at the start of the turn, to place a marker in a location that guarantees victory and doesn't allow the opponent to block. 
            For example: if the computer is red: berrree
        * If the AI goes second,when it makes its first move, it should go somewhat near 0,0.
            * This could be a hard-coded special case that considers the turn number.
            * It could c
    ADDING DEFUSERS TO HARD AND SOFT POWERS: (UNDERSTOOD)
        * Defusers of powers are useful to an opponent looking to reduce an opponents' power count.
        * Though some triggers are diffusers, not all are. Ex: ebbtte. If an enemy marker is placed on the right-most t, then there may still be power to the left. The assumption in this example, however, is that there is room to the left. If on either side of this pattern are enemy pieces, then every empty location in this pattern is a diffuser.
        * It is important to remember that any given SP usually matches several SP_Temps. The reason it is not so clear how to define a diffuser is, because all locations are diffusers if they fall within the bounds of a pattern match. But even though an SP pattern may have been broken, the SP as a whole may persist.
        * In order for a location to be considered a diffuser for an SP is if it is a diffuser for all of the SP_Temp patterns that match that SP. Thus, for an individual pattern, all non-marker locations are diffusers. For a recognized SP, only those diffuser locations which exist in all individual patterns are considered real diffuser locations. This must be considered during the pattern preprocessing and PoT collapsing activities.

    
Tuesday, March 2:
8:00 - 8:20 (0:20)
9:45 - 11:00 (1:15)
11:40 - 13:10 (1:30) 
15:30
17:30
    TODO:
        * [DONE] Modify cell_dict_gen() to not restrict output
        * [DONE] Have PoTs_dict automatically update.
        * [DONE] Evaluator
        * [DONE] Decider
        * [DONE] Modify game_loop and make AI_move
        * [DONE] Make AI choose random location if there is a tie in the evaluator score.
        * [DONE] make cell description more detailed by showing weights of each item
        * [DONE] add more controls at top of scrip to control overlay detail.
        * [DONE] add special case for first move as second player to place close to start
        * [] create AI debugging environment where I can step though a game and observe the AI's decision-making process.
        
    PROBABLY DO LATER:
        * [] Restructure user menu to reduce code repetition.
        * [DONE] Eliminate "playable_points", since the weighted sum constants effectively do that job already.
        
    MAYBE DO:
        * [DONE][INSUFFICIENT]. Add a category to the cell for blocking enemy Spots with minimal value to prevent completely stupid moves. Maybe more will be needed
        * [IGNORE] add a category of patterns which are winning moves, so as not to confuse them with simple threats.
        * [DONE] create some way to query points on a board and get a readout for how it is rated.
    
    BUGS:
        * [] undo confuses the AI
        * [FINE] potentially counts ST as booster. Maybe it should, since both are true.
        * [] did not trigger game-winning hard power. This was because the PPS did not include that point because of a soft threat against the AI.
        * [] Two enemy SP triggers in the same spot not recognized as dangerous.
        * [RECOGNIZED] SPot triggers are not being properly recognized.
        *** [] it is neccessary for the board to be a certain size to recognize patterns like efeeee. This should be fixed by making the board display size and the scanning bounds independent. For now, a bigger board. This will also affect how players move, since we will need to be able to move off the board if we make a thin border.

    AI:
        FUNCTIONS:
            * Evaluator: 
                * Accepts a cell_dict and returns a cell dict with added field for move value
                * Does not limit locations to PPS
            * Decider:
                * Receives a game and returns a location to move to
                * Uses the Evaluator
                * Applies tactical logic to limit PPS before picking tile most-valued by evaluator.
                * Has lots of DEBUGGING print statements to show logic of decisions.
            * modify new_game:
                * add option to select an AI opponent.
            * MODIFY game_loop or CREATE NEW ONE FOR AI?
                MODIFY:
                    * We could simply add a check at the end of the game_loopto see if an AI is playing.
                    * If an AI is playing:
                        * The game_loop is temporarily exited
                        * The AI makes a move
                        * The state variables are reset as though a human player just went
                        * We return to the game loop, and it is the human player's turn again.
            * AI_move:
                * Highest-level call in game_loop that takes move location from Decider and implements it correctly for the rest of the game to not freak out.
            
        THE OTHER CODE:
            * The code that rates a particular cell will change drastically even over a small number of iterations.
            * The rest of the code that allows the cell-rating code to make moves or allows a user to select whether to play a computer or play another player will not change as much.
            * Creating a simple cell-rating function and writing all of the "other code" that allows a computer to move would go a long way towards to allowing us to iterate our way to effective computer play.
        
    THOUGHTS:
        * If one was to get really abstract and AI-heavy, then it might be better to represent the game as a multi-dimensionsal matrix, including all of the triggers, and defusers and such. Though it would be difficult to inspect, it might be easier for a comupter to crunch through or learn from. But what do I know?

    EVALUATOR:
        * Makes use of following to make decisions:
            GOOD FOR SELF:
                    * if there is a friendly Hard Threat defuser (a winning move)
                    * If there is a friendly Soft Threat defuser that would lead to victory (NOT IMPLEMENTED)
                    * number of friendly SPot triggers (number of soft powers generated by moving there)
                    * number of friendly boosters (number of hard powers generated by moving there)
                    * number of SP triggers (number of STs that would be created)
                    * number of HP triggers (number of HTs that would be created)
                    * 
                BAD FOR OPPONENT:
                    * number of enemy hard threat defusers (defuse a hard threat to not lose the game)
                    * number of enemy soft threat defusers (defuse a soft threat to not lose the game)
                    * number of enemy soft power defusers (number of soft powers removed from enemy)
                    * number of hard power defusers (number of hard powers removed from enemy)
        ALGORITHM:
            * Weighted sum of all values is simplest.
                * Constants stored in named_tuple and passed to Evaluator. This may allow for a higher level of thought, where the "constant" values are manipulated in response to game conditions.
        RELATIVE IMPORTANCE OF CELL ATTRIBUTES:
            Since the weights are relative, we must understand each numbers' priority.
            It must be noted that this is a simplistic algorithm, and it may make absolutely silly decisions, because there really is no logic. The logic will come later once the ability to play against some AI is established.
            PROPOSED HEIRARCHY:
            |Values|Ranking|    
            | 1000.|1.     |HT_finish (friendly HT defusers): Going here should win the game.
            |  100.|2.     |HT_defusers: Going here is required to not lose the game immediately
            |   50 |2.5    |ST_finish (friendly ST_defusers): Going here to win in a coupld turns.
            |   10.|3.     |ST_defusers: Going here is required to not lose the game, though we could use hard threats.
            |    1 |4.     |boosters: Building hard power is very nice
            |    1 |5.     |SPot_triggers: Building soft power is nice
            |    1 |6.     |SP_triggers: Applying pressure is important
            |   0.5|7.     |HP_defusers: Nice to rid opponent of HP
            |   0.5|8.     |SP_defusers: Nice to rid opponent of SP
            |   0.1|9.     |HP_triggers: Unclear when to use HP, so will mostly ignore. Might make it difficult to win, but whatever.
            |  0.01|10.    |enemy_SPot_trigger: prevent enemy from being able to generate a soft power.

    QUESTIONS:
        * The presence of friendly Hard Power allows one to ignore soft threats for a time, but when do you choose to use them that way?
            * I think I only do it when I think I can win later. Mathematically and simplistically, this might just mean when I can create another hard power as a result.
    NOTICING VICTORY:
        * Some soft powers and hard powers are actually winning arrangements that simply need to be filled-in. These must be recognized to properly motivate
        * WHAT IS A POTENTIALLY GAME_WINNING SCENARIO?
            * Any friendly threats may be game-winning.
            * In the case of HTs, the AI should know how to win and do so.
            * In the case of STs, the AI should try to win and might; it make choose to go in the incorrect spot within the ST.
    
    PREVENTING STUPID MOVES IN BEGINNING: 
        * There is currently no reason for the AI to make any move on turn one. In the case of the first move, it has one choice and performs ok. In the case of the second move, it just goes in a useless corner.
        * I could add some score for going in an enemy's SPot trigger. This would require scanning through many SPots and potentially slow the computer's decision-making
            * This doesn't entirely work, since there are many SPot triggers around 0,0. So the AI just goes somewhere there.
        * This is partially helped by making the ai choose randomly from any tiles which each have the highest rating.
        * This is further helped by a special case that has the ai go in a random space within two of an alread-occupied tile if the choices of tiles is very poor.
        * This is further helped by a special case that has the ai go to (0,0) if the tile rating are all 0. This should only occur if the ai is playing the '1'.
        
Wednesday, March 3:
8:50 - 
    TODO:
        * [DONE] [FOR NOW]Improve visibility of pieces on board
        * [] Fix border display/scanning interdependencies
            * [] Make scanner start with "empty" characters
            * [] make scanner extend proper amount past the edge of the currently-displayed board
            * [] Allowing players to move off the board
        
    MAKING THE BOARD WORK BETTER:
        * I could have the board be the proper size to allow for scanning every which way and then just limit the display function.
        * I could allow the scanning function to go beyond the board as it exists.
        * I'd like the matrix of the board to be the minimum possible size, but then it needs to return empty values for values off the grid. getattr()?
    
        
