Thoughts, Monday Feb 8:
    * The game appears to be workable but needs some work.
    * First, it must be made more usable for human play through a terminal.
    * Secondly, we must create the capability to look at a game digitally, scanning along runs, and columns and such.
    TODO:
        * Add the ability to check if a given location has already been taken by a move(or what color it is)
        * Prevent players from placing moves where there already are some.
        * [DONE] Add ability to undo a move.
        * Add terminal interface to the game.
        * [DONE] Create a testing script that generates a game and runs through some moves.

Wednesday, Feb 10:
    TODO:
        * [DONE] Add ability to check if move is taken
        * [DONE]prevent players from making illegal moves
        * [DONE]Add automatic expansion of the game board
        * [DONE] add terminal interface
        * [DONE] Add handling of exceptions to terminal interface for situations like:
            * point off board
            * repeat point
            * non-int value
        * [] Update the demo notebook to showcase the game's capabilities
        * [FWD] Recognition of the game's end.
        * [] Tidy the repository, deleting random shit.
    POTENTIAL TODOS:
        * add scaling of the numbers to the size of the board so that how they look within the squares does not change.
        * add documentation to the code.
    On the expansion of the board:
        *[NOT DOING] It could be that the width and height of the board increases as neccessary and the aspect ratio is modified to maintain a square grid. This requires recognizing when a move is within n of the edge. Since most games usually approach one edge and not the opposite edge simulatenously, this would likely generate many squares that we don't even need.
        * [DONE] An alternative is to first redefine how the grid size is defined to not be inherently symmetrical across the x and y axes. This would allow us to expand just a single edge when needed and lead to better-looking games.
    How to recognize that a move is within two of the edge?:
        * The x (or y) coordinate would be more than the edge location-2. This could trigger the expansion of the boundary by one. 
        * The minimum distance to an edge can be calculated, and then that used to expand the border by n-spaces.
    On expanding the board:
        * Increasing the value for self.right_edge or any of the others would result in correctly drawing additional squares and gridlines. It would also increase the area in which moves are allowed. It would also modify the aspect ratio to maintain a square grid. The only missing piece seems to properly refresh the image displayed to the user.

Thursday, Feb 11:
    TODO:
        * [DONE] Transform game df data into matrix
        * [DONE] Scan columns and rows of matrix to fill queue
        * [DONE] Match patterns to queue contents to recognize end of game.
        * [DONE] Diagonal scanning
        * [DONE] incorporate end-of-game notice into playable game.
        * [] Consider different coordinate systems of game and matrices and its impact.
        * [DONE] Create helper functions for transforming game coordinates to matrix indices and vice versa.
        * [DONE] Come up with ways to mark board that makes it easier to place the move.
        
    THOUGHTS:
        * The next step seems to try and recognize patterns other than victory. Measuring and tracking soft and hard powers and threats could be a nice way to visualize a game.
        * It could be cool to have a mode where the recognized patterns are annotated directly on the plot. This would make debugging pattern detection much easier. Maybe just start with drawing a line over the winning series of moves. This could be done in a debug mode for starters. A notation that could be manually replicated owuld allow for comparison between us and the computer.
        * Adding methods like to_csv() and from_csv() would be good practice for other sitautions in which data is to be saved or loaded. It would also allow for the storage of games, making playing on the computer not imply that the game will be created and lost forever. These saved games would likely just be visualized, so some helper method for that would be good. Saving a game and playing it later would be good too; Maybe have a set number of games that can be saved, ask people for names to them, and display them like some sort of arcade game.

Friday, Feb 12:
    THOUGHTS:
        * It will be neccessary when working on pattern recognition to understand what is being recognized and where. Since it is not entirely clear even how we think about soft and hard powers and threats, the computer will certainly be a bit confused.
        * The terminology of soft and hard powers and threats is useful but may be insufficient. In the simple case of the eeexxeee arrangement, there is a single soft power and yet four possible, mutually-exclusive locations that would turn it into a soft threat. The terminology of soft and hard powers and threats refers to existing pieces and blanks, but does not talk about the locations where the new move would go.
        * New terms:
            *Soft Trigger: A location where, if a marker is placed, a soft power is transformed into a soft threat.
            *Hard Trigger: A location where, if a marker is placed, a hard power is trasnformed into a hard threat.
            
            Soft and Hard Triggers can coexist in a single tile, as is usually done to achieve a victory.
        
        
Saturday, Feb 13:
    THOUGHTS:
        * Could add step-through viewer for games, so that you can click the arrow keys to go forward and back. This would require a to_csv and from_csv-type methods that would allow saving and loading games. We would also need some sort of interface for interacting with the save files and displaying them. 
        * A library of games that allows you to step through them sounds pretty cool. Maybe even allow comments. Annotations should be optional to turn on or off. Stats displayed about the current slide and other slides as well, such as number of soft and hard power/threats for each player. Maybe a line graph where the past is filled-in and the future is alpha~=0.5.
        * The option to play a recorded game from a certain move is essential.
        * The ability to recognize similarities between games would be very cool. Might be difficult to recognize two games that are different but effectively identical, such as rotated games, transposed games, and reflected games. Games that were branches of other games should at least be recognizable as branches.
        * Add description of the game at launch, including victory condition and optional inputs
        * Maybe add an actual UI with buttons and shit.
        * It could be good to look into detecting key presses instaed of just text inputs.
        * Scaling the displayed numbers for the size of the grid could be nice.
        
        
Monday, Feb 15:
    THOUGHTS:
        * What are the benefits of tracking powers, threats, and triggers?:
            * The relative abosulte number of soft or hard powers between players might give an estimate of who is doing better.
            * The ratio of soft or hard powers to the number of moves made could give an estimate of how "tied up" or "free" someone's pieces are.
        * What are the benefits of tracking threats?:
            * The existence of a threat from the enemy is important to notice in order to properly react.
            * Unexpected victories usually come as a result of several moves which both trigger and generate power. The last move is usally in a location that is a trigger for multiple locations.
        * What are the benefits of tracking triggers?:
            * Two triggers in the same place indicate a location that will likely cause victory.
            * Triggers show us where we can go to force the enemy to make a move. Predicting where the enemy will go is already difficult for a person, and is inherently unpredictable.
        * What do we call the locations that you can place a move to prevent a threat from ending the game?
            * In the case of hard threats, there is usually only one place to go.
            * In the case of soft threats, there are usually a few options that allow you to block.
            * Any hard trigger is also an effective location for preventing a loss due to an enemy soft threat.
        * What metadata could each game have attached to it?
            * The names of the players and their colors
            * The name of the game itself. Could be autogenerated from the names and DateTime.
            * The date and time of the game.
        * What currently needs to be saved for a game?
            * The df
        * What needs to be recalculated after loading a game?
            * The location of the games edges
            * The game matrix
        
    TODO:
        * [DONE] Add Description of game at launch, including special character inputs
        * [DONE] Add to_csv, from_csv methods.
        * [DONE] Modify __init__ method to take an existing df.
        * [FWD] add detection of saved games
        * [DONE] add option to load a saved game or start a new one.
        * [FWD] Add comments to stuff
        * [] ? Add testing of loading and saving games
        * [FWD] implement autosave in case the game crashes.
        * [] option to save game image
        
        
    QUESTIONS:
        * Why does the use of exit() to end a game cause a SystemExit exception? Because that is literally all it is meant to do. The answer is to handle the exception at the highest level of your code, allowing you to gracefully exit from any point in your code. The use of os._exit(1) during the exception handling is an option to completely kill your program; in my experience seems to kill the kernel.
        
    IMPORTANT:
        * The game currently gets stuck trying to load a game after a save is performed. This could likely be helped by being able to check whether the specified filename is in the saves folder. If it is, then we can continue out of the input loop and simply load the game. This requires me to be able to list the contents of the saves folder.
        
Tuesday, Feb 16:
    TODO:
        * [DONE] Handle SystemExit exception
        * [DONE] add detection of saved games
        * [DONE] Fix issue of trying to load a game after playing a loaded game.
        * [DONE] Extract the selection of saves
        * [DONE] Create the game viewer.
        * [FWD] Add option to save and continue instead of just leaving

      
    * I think now that we have a viewer, it is a great time to implement the annotation for powers, threats, and triggers. The viewer (in a debug mode, potentially), will allow us to easily see how annotation generation is going.  
        
    Creating a step-through viewer for games:
        * Would be a third option alongside new game and loading.
        * Would load in a game as input
        * would listen to keyboard clicks for input
        * For each press, it essentially pretends that only a subset of the data exists and draws that.
        * A forward press increases the length of the data table
        * A backwards press reduces the length of the data table.
        * The enter key allows the user to start playing a new game from that point, with a double-check
        
    Should the viewer simply be built-in as part of playing a new or loaded game?:
        * Maybe later
        
    How to implement a viewer:
        * The game could have a view index which is normally set to "last" which determines location up to which information is displayed. For example, if a game that has gone for 10 moves has a view_index of 5, then retrieving the dataframe or displaying the markers will only show the first 5 moves. This would conflict with other properties, like the game board edges, which is something that gets calculated from the most recent DataFrame.
        * Passing the first n_rows of a game's dataframe into the game constructor would have the desired result. It then becomes a matter of keeping track of the index which we are interested in.
        
        
Wednesday, Feb 17:
    TODO:
        * [DONE] Add option to save and continue instead of just leaving
        * [DONE] Autosave
        * [DONE] Tell the user if a file already exists when saving
        * [DONE] Implement ability to play viewed game from the state that it is currently in.
        * [DONE] Replace some code with Input Handler for cleanliness
        * [DONE] Look into setting the size of the plot to be proportional to the number of squares in each dimension. This would prevent the displayed size of the pieces changing with the size of the board.
        * [DONE] simplify game loop
        * [PAUSED] choose some convention for how to count powers, threats, and triggers. 
        * [FWD] Add comments to stuff. Forces me to reinterpret and reevaluate existing code. 
        * [DONE] Adopt MITOCW testing framework
        * [FWD] Look into testing which involves interacting with the terminal.
        * [PAUSE] Allow '.' to separate move coordinates
        * [FWD] limit number of saves in saves folder.
        * [FWD] restructure scanning code
        * [DONE] Save completed games to records folder
        * [CANCELED] reorganize how different directions of scans have repeating code.
        * [DONE] compartmentalize the process of determining the save location, including asking about overwriting.
        * [FWD] Reassess categorization of class and static methods
        * [FWD] Add HP detection
        * [FWD] Add SP and HP visualization
        * [FWD] decide what to do about 'eefeffeee' being detected as a soft power with triggers in the -2 and -3 positions. Maybe check SP locations against HP locations to eliminate incorrect SPs. Maybe check for HPs first, and prevent creation of that SP.
        * [IGNORE] More-thoroughly test SP detection in different directions.
        * [DONE] Add calcaulation of powers and threats for games created from existing dfs.
        * [FWD] Create method that takes in a game and generates a game for each step in that game. The powers and threats in the game will then be aggregated and plotted.
        * [FWD]Add checking of ST and HT lists during creation of SPs and HPs. What about checking for HTs during ST generation? To do that, we would need to loop through the queue's yet again. We must also make sure that SPs are superceded by HPs. We need to loop through the queues 4 times to check for, in this order, HTs, STs, HPs, SPs, with each subsequent group checking if any match's markers are a subset of a match from a higher-order group.
    
    THOUGHTS:
        * There are still many things to clear up about how to store information about strong and weak powers, threats, triggers. These must be worked out on paper before any digitization makes sense.
        * I am getting to a point in the decision tree of my main game loop that some diverging paths converge again. The simplest solution to me seems to package any locations where paths converge as its own function, and just use that in both places in the tree. This could result in many unimportant functions, but it's all I got.
        * I process many simple inputs from the user, and it takes up a lot of lines of code with its while loop and shit like that. Maybe I can create some general input handler for simple cases.
        * There is an issue with double-counting sets of markers as both threats and powers. The solution i will try is to calculate threats first. If a power is detected and all of its markers belong to a single threat, then that will not be considered a power. This would prevent 'eefeffeee' from being considered both a SP and ST, which is good. This would also prevent 'eefffee' from being considered a hard power, which i am unsure about. We'll see.
        
    SIMPLE INPUT HANDLER:
        * A common case for handling inputs is a many-to-few case, where the user can input anything from a few lists. Any input that is included in any of the lists will case the output of a flag value indicating which bin was satisfied. Failure to provide a response within any of the categories elicits a prompt to the user. The flag value is used downstream of the input handling to determine what actions are performed. Since the performed actions can be quite complex and involve any variables from outside the input-handling context, the performed actions will not be supplied as inputs to the input handler.
        CASES THAT ARE NOT EASILY-COVERED:
            *When the input is checked for special values, and if all of those checks fail, the input is passed onwards.
            * When complex input verification is necessary, like whether something is an integer or passes a certain function. I suppose that the valid list of options for each output possibility could be replaced with a function that takes the user-supplied-input and returns True or False. The input_handler could check whether it was supplied a list or a function.
            * We currently check if the user input falls into a category. It also nice to check if some constant is contained within the user input, like a '.'
        
    REMINDER:
        * Just added processing of SP patterns. Not tested.
        * Next is to compare these patterns to the scanned queues and add the results some list of powers and triggers
        * The scanning will lkely need to be modified to reduce the repetition of code.
        * 
        
    
        LESSON: Hide as much input handling code as possibled. What we care about is the final decision, no matter how circuituous the path. Example, FIAR.save_name_input().
        
    STATIC vs CLASS METHODS:
        * Static methods should not modify the class object if they are handed one.
        * 
    
    Thoughts on combining the different scanning methods:
        * Each scanning method can be defined as a set of starting points from which you go a certain distance in a certain direction. This direction is the opposite of the tail direction, which we need to calculate marker and trigger locations when pattern matches are found.
    
    Thoughts on heirarchy of recognition for powers and threats:
        * One way to prevent double-counting of markers as soft and hard powers and threats is to loop through the queues 4 times.
        * Another way is to first generate all of the different powers and threats, only making sure that any equals within the groups are lumped together. Then we can systematically step through all of the STs and compare them to HTs. Then compare all of the HPs to the HTs and STs. Then compare all of the SPs to the HTs, STs, and HPs. This eliminates the need to loop 4 times through the queues.
Saturday, Feb 20th:
    TODO:
        * Reorganize code to allow for better scanning
        
    THOUGHTS:
        * It could be useful to look at the section in the Python Cookbook on data processing pipelines, since that is essentially what I am trying to do.
    THOUGHTS on Restructuring of scanning:
        * Parts:
            * Generate list of starting points for each scanning method
            * For each set of starting points, build your queues in a certain direction.
            * Perhaps this code spills out queues, their head locations, and tail directions.
            * These queues are scanned for powers and threats and recorded
            * The lists of powers and threats are scanned through again and collapsed within their individual categories. This would be most efficient in the context of a particular scanning direction.
            * The powers and threats are examined in heirarchical order to eliminate double-counts.
            
        * Do we need both a queue of len6 and queue of len5?
            * queue5 will always be the front 5 elements of queue6. The receiver of queues from queue_scan could just make queue5 on the spot.
        
        * If the code matching patterns to queues isn't concerned with overlapping powers then does it need to know the head_loc and tail_dir? I think not. it can just return a matching pattern.
            
    LESSON:
        * If you think the problem ahead is a bit unclear, even if you aren't willing to admit that it will be "hard", start with the documentation for individual functions. This will verify if the pieces as you imagine them fit together, clarify your goals when you are actually writing code, and is something that you'll have to do at some point anyway. If you wait to document until after you've written your code, you will find holes in your code that would not otherwise have been there, and you will not remember what everything does. Writing code in un-spec'd functions is a great way to muddy the scope of a function and to start writing unmodular code.
        * Always create your testing framework before coding anything. It is your eyes, and without it you are blind.


Tuesday, Feb 23:
    TODO:
        * 
        
    THOUGHTS:
        * There are likely many places where the use of generators would be beneficial.
        * I have hidden away the ugly generation of queues, but now I want access to the moments at which we switch rows to clear some memory. I could capture the switch from one row to another in the values that are returned by queues(), such as by structuring the queues in a nested data structure where it goes direction[starting_loc[queues[]]]
        
    SCANNING:
        * generate list of lists of lists of queues
        * unpack list of lists of lists of queues while matching patterns
        * Matched patterns for each category are compared heirarchically and repeats eliminated.
        
    We either go through all queues 4 times in order of the heirarchy of powers/threats and compare all new matches with the existsing ones in the same line of scanning OR we go through the queues once, generating overlapping powers and threats, and then clean them up later. It would be difficult to clean up the matches and eliminate repeated ones without knowing which pattern matches line up with each other.
    
    We could have a master list of PoTs. Each category of power or threat is run through and compared/added to the master list. Repeats are eliminated.
    
    PROBLEM:
        * By nesting my queues within their respective contexts of scanning direction and starting location, i was forced to generate a list of all the queues, which is very memory-intensive. Modifying the queue_gen to generate queues on demand but still in a layered format would be excellent, though potentially difficult. Could use some tips from the pipeline example.
        
Wednesday, Feb 24:
    TODO:
        * [DONE] Complete detection of all powers and threats
        * [DONE] Visualize Hard and soft powers and add it to the viewer
        * [] Reintroduce ending the game upon victory
        * [DONE] Add option to view record games
        * [DONE] Add some nice formatting to the terminal interface
        * [FWD] Switch to the viewer once a game has been completed
        * [FWD] Properly handle key.char lacking attributeError
    MAYBE TODO:
        * Make visualization of hard and soft powers toggleable
        * Store PoTs in a df.
        * Create some tests for PoT detection.
        * Extracting and plot PoTs for a game over time. Maybe lines
        * Generalize marker plotting function to draw both numbers and PoT markers
    DRAWING PoTs:
        Soft Powers:
            * Draw marker on trigger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Hard Powers:
            * Draw marker on triger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Soft Threats: 
            * Find any gaps between marker locations
            * Shade marker locations and gaps in grey or red
        Hard Threats:
            * Find any gaps between marker locations
            * Shade marker locations in darker grey or red.
            
    THOUGHTS:
        * We may want to not have Soft Threats eliminate overlapping hardpowers when detecting PoTs. This could be achieved by cmparing STs and HPs to the HTs list independenty, and then combinging all three. SPs would then have to be compared to the combined list and added.

Thursday, Feb 25:
    BACKUP TIME LOG:
        11:05-11:45
        11:55-12:55
        13:10-
    TODO:
        * [FWD] Properly handle key.char lacking attributeError
        * [DONE] Switch to the viewer once a game has been completed 
        * [DONE] Reintroduce ending the game upon victory
        * [DONE] If "None" provided for save name, no save made
        * [DONE] Implement SPotential
        * [DONE] Implement Defusers
        * [FWD] Create method that takes in a df and generates a df for each step in that game. Another functions wraps that and returns a game for each step instead.
        * [FWD] create some way to visualize SPots for debugging
        
    TODO CANDIDATES:
        * [FWD] Add way to extract summary statistics on a game and display them
        * [FWD] Add option to have PoT overlay on during regular gameplay
        * [FWD] Add way to judge the quality of a move
        
        * [FWD] Make the named tuples in which threats are stored have the opposite of trigger_locs, locations that defuse the threat. This could dramatically streamline decision-making for a player facing a threat. These locations could even be part of the overlay. 
        * [FWD] Add the drawing of defusers to the overlay. Maybe as a bold(for HTs) box around the defuser.
        * [FWD] Create a function for determining the Possible Play Space(PPS) for a particular player.
        * [FWD] Create a separate viewer class to store the viewer_index and improve compartmentalization. 
        
    PUT OFF:
        * [NEED INTERNET] Investigate the "AttributeError: module 'FIAR' has no attribute 'FIAR'" problem
        * [FWD] Create a separate type for each pattern, so that we don't rely on matching the first two letters of the name, and all instances of "Spots" can become "SPots".
        * [FWD] Indicate in the viewer what step you are at.
        * [FWD] Investigate the creation of too many figures when drawing markers.
        * [FWD] limit number of saves in saves folder.
        * [FWD] Add comments to stuff, especially inputs and outputs of functions and their types.
        * [FWD] Reassess categorization of class and static methods
        * [FWD] Look into testing which interacts with the terminal.
    
    BUGS:
        * [DONE] "Black victory detected" when last move made in viewer
        * [DONE] You can load a game that has already been won, have it ask for a move, and then say the game is over after the move is made no matter what. Instead, it would be preferrable if a game is checked for victory upon loading
        * [IGNORE] When you load a game that has been won already, the victory is immediately noticed and play ceases, but the user is still asked if they would like to save it. Whatever; they can just not save it if they like.
        * [] in games where there is a victory, the Viewer can misidentify it as a Hard THREAT.
    
    IMPLEMENTING SPOTENTIAL(SPots):
        TODO:
            * [DONE] Define a set of patterns which we are looking for.
            * [DONE] Mirror PoT implementation to spread SPots throughout the code.
                * [DONE] RAW pattern processing
            * [IGNORED] List SPots separately
            
            
    IMPLEMENTING DEFUSERS:
        TODO:
            * [DONE] Redefine STs and HTs to have their own NamedTuple, and debug that
                [DONE] changed Nmedtuple "name" to "names"
                [DONE] add defuser 'd's to the RAW patterns.
                [DONE] 'd' in pattern processing
                [DONE] have collapse_PoTs accept different threats without a "trigger_locs" property. Don't need to combine defusers from different threats, since they are never subsets of each other.
                [DONE] Have visualization work with different Types of PoTs
            * [DONE] Populate the defuser fields during PoT detection
            * [DONE] Add defuser visualization in the overlay.
    
    COLLAPSING SPots: (YES)
        *PoTs are collapsed by combining PoTs that share the same markers. Does this work for SPots? I think so
    
    OUTPUT of PROCESSING A GAME: 
        * All PoTs
        * Number of PoTs for each player
        * Whether a player has two simultaneous threats with different defuser locations
        * 
        
    JUDGING A MOVE: (PAUSED)
        * Individual moves can be good but bad within the larger context. For this reason, some understanding of the current state of the game is neccessary.
        * Numerically judging whether a move is decent becuase it creates or eliminates powers is very possible. However, we often make constrained moves depending on what threats and powers we and our enemy have.
        REALISTICALLY:
            * Evaluate each tile as a weighed sum of addition or removal of PoTs to self or enemy, respectively.
            * Calculate balance of power by comparing total number of PoTs for each player.
            * Modify relative value of adding or subtracting PoTs depending on relative balance of power.
        LIKELY IMPOSSIBLE:
            CONCENTRATIONS OF PoTs:
                * One should be less afraid of enemy powers that are separate that those are close together. 
                * Could try some sort of "nearest-neighbor" stuff to identify clusters. Maybe have a maximum distance from the cluster center beyond which powers don't count.
                * Inclined to track concentrations of triggers, since those are the locations where pieces would be placed and the game would "happen". 
                * Tracking the marker locations might not recognize a confluence of triggers from different directions.
                * A concentration of Pots would have values for location, total_span, total_strength, density, and maybe more.         
            SEVERAL MOVES AHEAD:
                * It is often the case that by spending hard powers and effectively choosing where your opponent goes that you can think several moves ahead with absolute certainty. Being able to think several moves ahead would allow a computer to individually rate each of those successive moves and decide that it's a good idea.
            RECOGNIZE FORCING ENEMY MOVES
                Even if the computer does not plan more than one of its moves in a row, it could at least recognize that triggering a hard power means choosing where the opponent goes, and try to evaluate the "goodness" of that spot for the enemy; you wouldn't want to force your opponent to win, for example, even if you'd gain a bunch of soft power. Though one could easily judge that using a hard power which forces the opponent to win is a bad idea, it would be harder to compare two non-game-ending moves where one
        CONDITIONAL-CONSTRAINT LOGIC_ROUGH:
            STEP-BY-STEP:
                    Tile Evaluator    
                        * Possible Play Space (PPS) are defined by all tiles within a certain distance of already-played pieces.(Maybe just the whole board, since it scales)
                        * If there is a hard threat against me:
                            * PPS of one location: the defuser of the HT.
                        * Elif there is a soft threat against me:
                            * PPS is the union of enemy ST defusers and your own HP triggers
                        * Evaluate entire PPS through some formula
                    AI:
                        * Run Tile Evaluator
                        * Pick the location with the maximum value
                        * Place a move there.
                    Advisor:
                        * Run Tile Evaluator
                        * Pick top three moves and draw them on the overlay
                        
                        
    NEW TERMINOLOGY: (YES)
        * Defuser: A location which if a player was to go there, would cause an enemy threat to stop existing. Inverse of a trigger.
    
    Terminal Interface Testing: (YES)
        * Instead of being listened to, the keyboard can be emulated, and this can allow us to test the terminal interface.
        
    SPotential (SP predeccesors): (COVERED)
        * It could be useful to track the predeccessors to SPs. 
        * Their number indicates a player's ability to create SPs, which is important. Qualitatively, this would reflect how constrained your markers are.
        * This will be called SPotential, because that's a great name.
        * Tracking SPotential and it's triggers would allow us to judge whether a move would add or subtract soft power.
        * SPotential would likely not be displayed on the overlay, because it would create too much clutter.
    
    WHAT ARE THREATS ANYWAY?:(ANSWERED)
        * A hard threat is something that unless you defuse it wil make you lose the game in one turn.
        * A soft threat is something that unless you defuse it or use a hard power will make you lose the game in two turns.
        Is the intersection of triggers from two soft powers a threat?
            Conclusion:
                * Because it is possible to ignore a tile with ovelapping triggers from two soft powers and not be guaranteed to lose the game, this situation is not to be considered a "threat"
                * Because this tile with overlapping triggers from two soft powers is still quite dangerous, this should be reflected in the equation that rates moves. This could be treated as a special case, "A tile with two different enemy triggers", or come naturally, "Moving here will simultaneously reduce the enemy's total soft power count by two.
            Reasoning:
                * It is certainly dangerous, and I would prioritize that spot highly whether it was my move or the enemy's.
                * If ignored, the enemy could trigger both soft powers simultaneously
                * It is possible to prevent defeat at this point if you can simulatenously defuse on of the soft threats and create your own hard threat
                * As long as the defuser for your hard threat isn't also a trigger for an enemy power, you could then defuse the second enemy threat and not be "threatened".
   
   POWER vs SPotential: (COVERED)
    * POWER the ability to create a threat with a single move.
    * SPotential is the ability to create a soft power with a single move.
    * Neither influences the enemy's move very much, and so both of their importance is derived from the fact that they can eventually createa a threat. As such, it seems that they should essentially be treated as unequals from the same category.
    * Should SPotential be eliminated if its markers overlap with that of an existing power or threat?
        * If the lines along which they are looking are different, no.
        * If the lines along which they are looking are the same, maybe. We could implement that easily-enough if need be.

Friday, February 26:
    TODO POTENTIALLY:
        * [FWD] Add legend to viewer for PoTs
        * [FWD] add a forfeit option
        
    * Maybe put 0,0 move automatically?
    * When rating a move, rate moves for your opponent and see if there is a really good spot that they might want. This would mostly be spots that generate soft powers, since anything higher-order would show up as powers or threats.
    
    BUGS:
        * opened a completed game in the viewer when asked. Stepped around, and eventually tried to continue from a previous point. Immedaitely got an improper victory message and was asked to save. Happens even if you restart kernel and open viewer again.

Monday, March 1:
7:30 - 9:05 (1:35)
9:55 - 11:25 (1:30)
11:35 - 15:20 (3:45)
16:40 - 18:50 (2:10)
19:15 - 19:40 (0:25)
19:50 - 20:40 (0:50)

    TODO:
        * [IGNORED] Restructure Viewer as separate class that holds its own value for the view index
        * [DONE] Move the victory pattern recognition to somewhere that the viewer won't trigger.
        * [DONE] Reset victory flag properly.
        * [DONE] Properly handle key.char lacking attributeError
        * [DONE] Create method that takes in a df and generates a df for each step in that game. Another functions wraps that and returns a game for each step instead.
        * [DONE] create some way to visualize SPots for debugging
        * [DONE] Create a function for determining the Possible Play Space(PPS) for a particular player.
        * [DONE] Add option to have PoT overlay on during regular gameplay
        * [DONE] Add HPots to the game.
        * [DONE] Add defuser locations to Soft Powers for AI
        * [DONE] Add defuser locations to Hard Powers for AI
        * [DONE] Generate a dict of Cells that contain information on PoTs
        
    TODO CANDIDATES:
        * [] Add way to extract summary statistics on a game
        * [] add way to extract summary statistics on the entire history of a game
        * [] Add way to display summary statistic on a game
        * [DONE] Add way to judge the quality of a move
        * [IGNORED] Create a separate viewer class to store the viewer_index and improve compartmentalization. 
        * [DONE] Add choice of whether to play 2 player or against a computer
        
    PUT OFF:
        * [NEED INTERNET] Investigate the "AttributeError: module 'FIAR' has no attribute 'FIAR'" problem
        * [] Create a separate type for each pattern, so that we don't rely on matching the first two letters of the name, and all instances of "Spots" can become "SPots".
        * [IGNORE] Indicate in the viewer what step you are at.
        * [IGNORE] Investigate the creation of too many figures when drawing markers.
        * [IGNORE] limit number of saves in saves folder.
        * [] Add comments to stuff, especially inputs and outputs of functions and their types.
        * [] Reassess categorization of class and static methods
        * [] Look into testing which interacts with the terminal.
    
    BUGS:
        * [IGNORE] When you load a game that has been won already, the victory is immediately noticed and play ceases, but the user is still asked if they would like to save it. Whatever; they can just not save it if they like.
        * [] in games where there is a victory, the Viewer can misidentify it as a Hard THREAT.   
        
    ITERATING THROUGH GAMES: (SOLVED)
        * To step through each state of a game, it would be nice to first step through every state of a df and wrap that.
        * If we only needed to iterate through the games, then I could add an iterator protocol to the FIAR class. That might actually still be the best move; using a DF iterator within it might be possible.
        
    VIEWER OBSERVATIONS: (DONE)
        * When the overlay is turned on and off, the "Powers and Threats" are reprinted. This may indicate that they are being recalculate unneccessarily as well.
    
    THOUGHTS:
        * it might be interesting to differentiate between games and views of games.
        
    DETERMINING THE PPS (DONE):
        * Possible Play Space (PPS) are defined by all tiles within a certain distance of already-played pieces.(Maybe just the whole board, since it scales)
            * If there is a hard threat against me:
                * PPS of one location: the defuser of the HT.
            * Elif there is a soft threat against me:
                * PPS is the union of enemy ST defusers and your own HP triggers
            * Evaluate entire PPS through some formula
            
    ROADMAP TO AI:
        * There is a list of properties for each cell that is relevant to the decision-making process of the current player
        * Given a game: 
            * a dict of cells is created of the appropriate size
            * All the PoTs, SPots, and HPots are cycled through and their relevant locations are added to the cells' properties.
        * If we create a dict of cell objects, each with all the relevant properties:
            * we can scan through all SPots and PoTs and add their triggers and defusers to the relevant cell
            * we can then iterate through all of the cells with PPS and apply a formula to them. The largest number is the best move
        * The best move is then made by the computer.
        * PROPERTIES NEEDED FOR FIRST VERSION OF AI:
            * GAME-WIDE:
                * 
            * CELL-SPECIFIC:
                * The location of the cell
                GOOD FOR SELF:
                    * if there is a friendly Hard Threat defuser (a winning move)
                    * If there is a friendly Soft Threat defuser that would lead to victory (NOT IMPLEMENTED)
                    * number of friendly SPot triggers (number of soft powers generated by moving there)
                    * number of friendly boosters (number of hard powers generated by moving there)
                    * number of SP triggers (number of STs that would be created)
                    * number of HP triggers (number of HTs that would be created)
                    * 
                BAD FOR OPPONENT:
                    * number of enemy hard threat defusers (defuse a hard threat to not lose the game)
                    * number of enemy soft threat defusers (defuse a soft threat to not lose the game)
                    * number of enemy soft power defusers (number of soft powers removed from enemy)
                    * number of hard power defusers (number of hard powers removed from enemy)
                    * 
        * PROPERTIES POTENTIAL FOR FUTURE VERSIONS OF AI:
            * GAME-WIDE:
                * Ratio of all own powers to enemy powers. (Determines how important it is to bolster self or weaken enemy).
            * CELL-SPECIFIC:
                * number of empty tiles around the tile
                * Whether it is on-grid with other markers of yours nearby
                * How many enemy neighbors it has. A measure of freedom.
                
    HARD POWER PREDECCESORS: (DONE)
        * It would be useful to know if moving on a location would generate a hard power.
        * Any friendly move in a soft power which does not generate a soft threat will generate a hard power.
        * Hard-power generating locations are currently denoted with 'e' in the raw patterns or '+' in the matching patterns. During pattern processing, we could add another category, booster_locs, which hold these other locations.
        * What to call them?:
            * They generate hard powers
            * Erectors?
            * Harder_locs?
            * Harden?
            * Empower_locs?
            * booster
        * Are there non-SP predeccesors to HPs that we are not considering?
            * YES, sadly. Since HPs patterns are only 5 long and SPs are 6 long, there are plenty of HP predeccesors which are not themselves soft powers.
            * We can create a group called HPots, which are predeccesors of hard powers. These will be recognized like any other pattern and saved. There relationship to SPs could be:
                1. (CHOSEN) Subordinate to SPs. Any HPot that shares all of its markers with an SP is considered to not exist, and a tile in that SP leading to a HP will be a booster. Any HPot which is not an SP will exist, and it will also have boosters that indicate whether a move will create a hard power. CHOSEN
                2. Indepenent of SPs. All HPots exist, even if they share markers with SPs. This means that SPs will not have boosters, and that all hard power-generating tiles will be boosters or triggers in HPots. This also means that SPs and HPots will be double-counted, and it will not be clear from an HPot whether it is part of an SP or not.

    INFERRING THE CONSEQUENCES VS SEEING THEM:
    Conclusion: 
        We will go with the inferrential approach, because it allows us to make decisions without having to simulate a bunch of moves. Additionally, we've been able to answer all the questions that we've come up with using the inferrential approach. If we ever try to think n-moves ahead, the clarity of vision that the inferrential approach provides is much superior to the O^n complexity that the brute force approach has.    
    Broadly, we have two approaches before us:
        INFERRING CONSEQUENCES:
            Refers to the process of analyzing points on the map as triggers or defusers of powers or threats, and then deciding which is most important.
            * This approach seems more elegant, but requires more upfront work to notive every possible change that a move might cause. It becomes quite subtle when we start talking about adding or removing different types of powers. If we ever reach a situation in which we cannot recognize a certain consequence without brute force, then we will be forced to resort to the brute-force method.
        SEEING CONSEQUENCES:
            Refers to the brute force approach of considering the possibility of moving onto any given square and then seeing how the number of powers and threats has changed.
                * This approach is much more computationally expensive, and may even approach being prohibitive, since each possible move generates a new board which is then fully scanned through.
            
    NECCESSARY BEHAVIORS OF THE AI:
        * If a friendly soft threat remains at the start of the turn, to place a marker in a location that guarantees victory and doesn't allow the opponent to block. 
            For example: if the computer is red: berrree
        * If the AI goes second,when it makes its first move, it should go somewhat near 0,0.
            * This could be a hard-coded special case that considers the turn number.
            * It could c
    ADDING DEFUSERS TO HARD AND SOFT POWERS: (UNDERSTOOD)
        * Defusers of powers are useful to an opponent looking to reduce an opponents' power count.
        * Though some triggers are diffusers, not all are. Ex: ebbtte. If an enemy marker is placed on the right-most t, then there may still be power to the left. The assumption in this example, however, is that there is room to the left. If on either side of this pattern are enemy pieces, then every empty location in this pattern is a diffuser.
        * It is important to remember that any given SP usually matches several SP_Temps. The reason it is not so clear how to define a diffuser is, because all locations are diffusers if they fall within the bounds of a pattern match. But even though an SP pattern may have been broken, the SP as a whole may persist.
        * In order for a location to be considered a diffuser for an SP is if it is a diffuser for all of the SP_Temp patterns that match that SP. Thus, for an individual pattern, all non-marker locations are diffusers. For a recognized SP, only those diffuser locations which exist in all individual patterns are considered real diffuser locations. This must be considered during the pattern preprocessing and PoT collapsing activities.

    
Tuesday, March 2:
8:00 - 8:20 (0:20)
9:45 - 11:00 (1:15)
11:40 - 13:10 (1:30) 
15:30
17:30
    TODO:
        * [DONE] Modify cell_dict_gen() to not restrict output
        * [DONE] Have PoTs_dict automatically update.
        * [DONE] Evaluator
        * [DONE] Decider
        * [DONE] Modify game_loop and make AI_move
        * [DONE] Make AI choose random location if there is a tie in the evaluator score.
        * [DONE] make cell description more detailed by showing weights of each item
        * [DONE] add more controls at top of scrip to control overlay detail.
        * [DONE] add special case for first move as second player to place close to start
        * [] create AI debugging environment where I can step though a game and observe the AI's decision-making process.
        
    PROBABLY DO LATER:
        * [] Restructure user menu to reduce code repetition.
        * [DONE] Eliminate "playable_points", since the weighted sum constants effectively do that job already.
        
    MAYBE DO:
        * [DONE][INSUFFICIENT]. Add a category to the cell for blocking enemy Spots with minimal value to prevent completely stupid moves. Maybe more will be needed
        * [IGNORE] add a category of patterns which are winning moves, so as not to confuse them with simple threats.
        * [DONE] create some way to query points on a board and get a readout for how it is rated.
    
    BUGS:
        * [] undo confuses the AI
        * [FINE] potentially counts ST as booster. Maybe it should, since both are true.
        * [DONE] did not trigger game-winning hard power. This was because the PPS did not include that point because of a soft threat against the AI.
        * [] Two enemy SP triggers in the same spot not recognized as dangerous.
        * [DONE] SPot triggers are not being properly recognized.
        *** [DONE] it is neccessary for the board to be a certain size to recognize patterns like efeeee. This should be fixed by making the board display size and the scanning bounds independent. For now, a bigger board. This will also affect how players move, since we will need to be able to move off the board if we make a thin border.

    AI:
        FUNCTIONS:
            * Evaluator: 
                * Accepts a cell_dict and returns a cell dict with added field for move value
                * Does not limit locations to PPS
            * Decider:
                * Receives a game and returns a location to move to
                * Uses the Evaluator
                * Applies tactical logic to limit PPS before picking tile most-valued by evaluator.
                * Has lots of DEBUGGING print statements to show logic of decisions.
            * modify new_game:
                * add option to select an AI opponent.
            * MODIFY game_loop or CREATE NEW ONE FOR AI?
                MODIFY:
                    * We could simply add a check at the end of the game_loopto see if an AI is playing.
                    * If an AI is playing:
                        * The game_loop is temporarily exited
                        * The AI makes a move
                        * The state variables are reset as though a human player just went
                        * We return to the game loop, and it is the human player's turn again.
            * AI_move:
                * Highest-level call in game_loop that takes move location from Decider and implements it correctly for the rest of the game to not freak out.
            
        THE OTHER CODE:
            * The code that rates a particular cell will change drastically even over a small number of iterations.
            * The rest of the code that allows the cell-rating code to make moves or allows a user to select whether to play a computer or play another player will not change as much.
            * Creating a simple cell-rating function and writing all of the "other code" that allows a computer to move would go a long way towards to allowing us to iterate our way to effective computer play.
        
    THOUGHTS:
        * If one was to get really abstract and AI-heavy, then it might be better to represent the game as a multi-dimensionsal matrix, including all of the triggers, and defusers and such. Though it would be difficult to inspect, it might be easier for a comupter to crunch through or learn from. But what do I know?

    EVALUATOR:
        * Makes use of following to make decisions:
            GOOD FOR SELF:
                    * if there is a friendly Hard Threat defuser (a winning move)
                    * If there is a friendly Soft Threat defuser that would lead to victory (NOT IMPLEMENTED)
                    * number of friendly SPot triggers (number of soft powers generated by moving there)
                    * number of friendly boosters (number of hard powers generated by moving there)
                    * number of SP triggers (number of STs that would be created)
                    * number of HP triggers (number of HTs that would be created)
                    * 
                BAD FOR OPPONENT:
                    * number of enemy hard threat defusers (defuse a hard threat to not lose the game)
                    * number of enemy soft threat defusers (defuse a soft threat to not lose the game)
                    * number of enemy soft power defusers (number of soft powers removed from enemy)
                    * number of hard power defusers (number of hard powers removed from enemy)
        ALGORITHM:
            * Weighted sum of all values is simplest.
                * Constants stored in named_tuple and passed to Evaluator. This may allow for a higher level of thought, where the "constant" values are manipulated in response to game conditions.
        RELATIVE IMPORTANCE OF CELL ATTRIBUTES:
            Since the weights are relative, we must understand each numbers' priority.
            It must be noted that this is a simplistic algorithm, and it may make absolutely silly decisions, because there really is no logic. The logic will come later once the ability to play against some AI is established.
            PROPOSED HEIRARCHY:
            |Values|Ranking|    
            | 1000.|1.     |HT_finish (friendly HT defusers): Going here should win the game.
            |  100.|2.     |HT_defusers: Going here is required to not lose the game immediately
            |   50 |2.5    |ST_finish (friendly ST_defusers): Going here to win in a coupld turns.
            |   10.|3.     |ST_defusers: Going here is required to not lose the game, though we could use hard threats.
            |    1 |4.     |boosters: Building hard power is very nice
            |    1 |5.     |SPot_triggers: Building soft power is nice
            |    1 |6.     |SP_triggers: Applying pressure is important
            |   0.5|7.     |HP_defusers: Nice to rid opponent of HP
            |   0.5|8.     |SP_defusers: Nice to rid opponent of SP
            |   0.1|9.     |HP_triggers: Unclear when to use HP, so will mostly ignore. Might make it difficult to win, but whatever.
            |  0.01|10.    |enemy_SPot_trigger: prevent enemy from being able to generate a soft power.

    QUESTIONS:
        * The presence of friendly Hard Power allows one to ignore soft threats for a time, but when do you choose to use them that way?
            * I think I only do it when I think I can win later. Mathematically and simplistically, this might just mean when I can create another hard power as a result.
    NOTICING VICTORY:
        * Some soft powers and hard powers are actually winning arrangements that simply need to be filled-in. These must be recognized to properly motivate
        * WHAT IS A POTENTIALLY GAME_WINNING SCENARIO?
            * Any friendly threats may be game-winning.
            * In the case of HTs, the AI should know how to win and do so.
            * In the case of STs, the AI should try to win and might; it make choose to go in the incorrect spot within the ST.
    
    PREVENTING STUPID MOVES IN BEGINNING: 
        * There is currently no reason for the AI to make any move on turn one. In the case of the first move, it has one choice and performs ok. In the case of the second move, it just goes in a useless corner.
        * I could add some score for going in an enemy's SPot trigger. This would require scanning through many SPots and potentially slow the computer's decision-making
            * This doesn't entirely work, since there are many SPot triggers around 0,0. So the AI just goes somewhere there.
        * This is partially helped by making the ai choose randomly from any tiles which each have the highest rating.
        * This is further helped by a special case that has the ai go in a random space within two of an alread-occupied tile if the choices of tiles is very poor.
        * This is further helped by a special case that has the ai go to (0,0) if the tile rating are all 0. This should only occur if the ai is playing the '1'.
        
Wednesday, March 3:
8:50 - 10:50 (2:00)
11:05 - 11:40 (0:35)
12:10 - 14:40 (2:30)
15:40 - 16:25 (0:45)
    TODO:
        * [DONE] [FOR NOW]Improve visibility of pieces on board
        * [TESTING] Fix border display/scanning interdependencies
            * [DONE] Make scanner start with "empty" characters
            * [DONE] make scanner extend proper amount past the edge of the current game board
            * [DONE] Allowing players to move off the board
            * [DONE] extract empty chars from matrix when asking for things out of bounds
            * [DONE] investigate cy,ij conversions
        * [DONE] FIXING AI
            * [DONE] Fix playable_locs
            * [DONE] get ai to play
        *[FWD] not display board unil playing
        * [FWD]  notice HP triggers that are also SP triggers
        
        
    BUGS:
        * [DONE] When drawing overlay, some triggers are drawn off the board.
        * [] not drawing spacing markers. Drew it in the wrong place
        * [DONE] turn 10, mackenzie's game 'iRobot', thinks it made 3 soft powers instead of 2 at (-3,0)
        * [] viewer turns on in respons to 'n'
        * [DONE] queues_gen IS GIVING US FAULTY QUEUES
        
    MAKING THE BOARD WORK BETTER:
        * I could have the board be the proper size to allow for scanning every which way and then just limit the display function.
        * I could allow the scanning function to go beyond the board as it exists.
        * I'd like the matrix of the board to be the minimum possible size, but then it needs to return empty values for values off the grid. getattr()?
    
    CURRENT BOARD INFO:
        * draw_board uses the game.left_edge, game.top_edge, etc params to determine the size of the board displayed.
        * game.left_edge is set by initial size of board
        * game.left_edge is increased by scanning through game and determining if there are pieces that are too close to the border.
             * This is silly. Easier to simply find min/max of x/y for all moves, add the border thickness and set the new game edges.
        * _move_ currently determines if a move is valid by comparing it to game.left_edges, etc, which is not something we want.

Thursday, March 4:
8:20 - ?

    TODO:
        * [DONE] Fix AI
        * [] not display board unil playing
        * [] Notice friendly and enemy intersections of power
        
    Thoughts:
        * Could have rating for being on-grid with nearest friendly marker.
        
    What Special things to look for in a cell that doesn't simply fall under the weighted sum model?
        * The presence of two or more friendly soft or hard power triggers. This is potentially game-winning, and going there should be a priority
        * The presence of two or more enemy soft or hardpower triggers. This is also potentially game-ending.
        PRIORITIES:
            * Two friendly SP triggers are less important than defusing an enemy ST.
            * One friendly HP trigger and one more SP or HP trigger is more important than an enemy ST.
            * Two enemy SP triggers are less important than a ST_finish
            * Two enemy HP triggers are less imporatnt than a HT finish or HT_def, but nothing else.
    DESIRED AI BEHAVIOR:
        * The ai , if faced with two STs, will prioritize a defuser which is also a friendly HP trigger
        
    WEIGHTED SUM AND SPECIAL CASES:
        * The theory behind using a weighted sum is that it will inherently prioritize certain behaviors based on the weights.
        * In special cases, like the increased importance of triggers when there are two of them, this weighted sum routine is superceded by another decision-making mechanism. If this decision-making mechanism affects the total calculated by the weighted sum, then this is a poor method, because it distorts the picture without any explanation.
        * Currently, the weights are constants in an implied multiplicative relationship with their corresponding counts. Alternatively, the weights could themselves be complex functions. For example, the function for weighing the importance of SP_triggers could increase with their number. Maybe 1.25 points for 1 and 5 for more than 1. This could potentiall be approximated with some sort of parabolic function, but I am looking for something more piecewise.
        * The use of piecewise functions for weighing counts assumes that there are no interactions between counts, but there are, like in the case of SP_trigs and HP_trigs. If there is one
        * I must store the individual contributions to the total rating of a cell. This makes the most sense to do in the cell. There could be a named tuple for each category consisting of 'count' and 'value'.
        
        
    ON CODE STRUCTURES THAT RATE CELLS:
        CURRENTLY:
            * cell features are stored in a Cell object
            * a total rating for a cell is calculated by a function external to the Cell and modifies the Cell's 'rating' property.
        ONE POSSIBLE WAY:
            * cell features are stored in a cell object
            * each feature in the cell object also has an aggregated value
            * The cell updates it's own feature values using its own method, then sums them up
            * A cell grid stores all of the cells and has methods like finding the one with the highest rating, and asking them all to update.
            * The cell grid accepts a game to create itself.
            * why not make the cell grid belong to the game? Well, there is the weirdness about the cells not using all the features that we detect, and there is a dependency on whose turn it is.
        SMART DATA STRUCTURES:
            * The game currently has several different data structures that are all calculated successively. They all use various game methods to accomplish their tasks, and they have various methods for their use once created. These could all be their own objects with their own methods. This would likely make the game class much cleaner and all the code in general easier to understand.
            * Candidates for independent classes:
                * Cell (already implemented)
                * Cell Array
                * matrix
                * PoTs, including Pots dict by type.
                * viewer
                * Terminal Interface
                * game analyzer
                * game visualizer
            Where does each function go?:
                * 
    REDESIGNING THE INTERFACE TO BE A SEPARATE FINITE STATE MACHINE:
        * There is not a lot of code in the terminal interface, but it does get reused quite often, and it is silly to keep writing out the same function calls.
        * The current design essentially has states already, but they are not explciit and likely not tidy.
        * Because the current design is that of conditional branching, many features have not been implemented in many branches.
        * STATES:
            * Main Menu
            * Two Player game
            * AI game
            * saving game
            * loading game
            * Viewing
        * SUBROUTINES:
    
    VIEWER CLASS:
        The purpose of the viewer class is to display previously-played games.
        ABILITIES:
            * Step through a game from beginning to ending
            * analyze a game through the lens of Powers and Threats
            * analyze a game through the eyes of an AI
            * display varying levels of detail concerning the overlay
            * To start playing a game that is being viewed.
        ATTRIBUTES:
            * game
            * current viewing step
            * 
        METHODS:
            * increment viewing step
            * decrement viewing step
            * Turn overlay on/off
            * modify contents of overlay
            * 
        POTENTIAL INTERACTION WITH INTERFACE:
            * Interface asks user questions
            * User decides to view a game
            * Interface calls the viewer into action and passes it a game
            * User clicks around in the viewer
            * User decides to play the current game
            * If the viewer is a state of the interface, then it simply switches state.
    OVERLAP BETWEEN DIFFERENT ACTIVITIES:
        * When I play, I want to be able to play against a player or ai and have the option to see the power overlay, see ai decisions
        * When in the viewer, I want to be able to make moves, see ai suggestions.
        * I think this could be satisfied with a viewer, a game, an analyzer.
     
    INTERFACE CLASS:
        OVERLAP BETWEEN NEW_GAME AND LOAD_GAME:
            * Both determine whether to play PvP or PvAI
                * If PvP, which color is ai?
            * Both determine whether to have the overlay on
        DIFFERENCES BETWEEN NEW_GAME AND LOAD_GAME:
            * New game asks who plays first. Load game has an implied next player
            
        NEW_GAME ORDER:
            * pvp or ai
            * self color
            * turn order
        
        LOAD_GAME ORDER:
            * pvp or ai
            * self color
        
        WHERE DOES SELECTED INFO GO?
            * first player info given to FIAR
            * player_color stored
            * 
        WHEN DO YOU USE A STATE AND WHEN DO YOU USE A SUBROUTINE?
            * By making the player move loop a funciton of the parent class, and redefining undo() for PvPGame and PvAIGame, I can effectively use the same loop for both states. However, it is odd for that loop to not be its own state. But if it was its own state, it could not use those two different undo() methods.

Wednesday, March 10:
    TODO:
        * [] not display board until playing
        
    TERMINAL INTERFACE:
        * I have been refering to the terminal interface, when I really meant the IDE debugging interface. A true terminal interface should work straight from a terminal. 
        ABILITIES:
            WORK IN SEVERAL ENVIRONMENTS:
                * in Spyder for debugging purposes
                * kTinker window.
            * ask user what environment it is being run in.
            * Wipe the terminal every move
                * os.system('clear' or 'close')
            * Close external figure windows.
                * plt.close(fig). Sometimes works
            * turn plt.ion() or plt.ioff() as needed
                * plt.ioff() delays drawing changes until fig.show() is used.
                * plt.ion() allows us to interact with an already open figure, including closing it.
    HOW DO I IMAGINE TKINTER WINDOW BEING USED?
        METHOD 1:
            * run run.py in terminal
            * tkinter window pops up
            * go through setup questions in tkinter
            * tkinter accepts move inputs.
    FUCK TERMINAL INTERFACE:
        * The terminal interface is clunky at best and always limiting.
        * The terminal interface already works (for me), and developing it further will be quite limiting.
        * I will pour my efforts into a fully-GUI application that is much more flexible, robust, and better.
        
Monday, March 15:
9:00 - 10:30 (1:30)
11:00 - 11:15 (0:15)
11:50 - 14:30 (2:40)
    TODO:
        * Simple Plotting Example using QT Designer
            * Simple Plotting Example using manual QT
            * Simple QT Designer example whose python code is compared to previous manual QT
            * Combine QT designer example with plotting
        
    
    WHAT TO ADD TO FIAR BEFORE BEING DONE:
        * Graphic Interface
        * Improved AI
            * Noticing FICKS
        * Refactoring of code into presentable pieces.
        * Summary statistics across lenth of game
        * 
    
    WHAT TO NOT ADD BEFORE BEING DONE:
        * Proper Terminal Interface
        
    GRAPHIC INTERFACE WINDOWS:
        MAIN MENU:
            * New Game button
            * Continue button
            * Records button
            * Options button
        NEW GAME OPTIONS:
            Selections made before playing new game
            * PvAI or PvP
            * Red or Black goes first
            * If PvAI:
                * Player and AI colors
                * ?Show AI rational for moving.
        CONTINUED GAME OPTIONS:
            Selections made before continuing a game
            * PvAI or PvP
            * If PvAI:
                * Player color
        SAVED GAMES TO CONTINUE:
            * Several slots that are all displayed simultaneously
                * Includes Autosave
        Options:
            * Allow basic overlay to be toggled?
            * Allow heat map to be toggled?
            * Highlight the cell whose numbers have been entered into the x,y coords box(es)?
        RECORDS (CANCELED):
            * Scrollable frame with all record games
            * Back button
            * View Selected Game button
        VIEWER:
            * Large frame with current stage of game
            * Plot of powers vs time above game, with shading used to indicate where we are along in the process
            * Toggle for overlay
            * Left and Right arrows to allow stepping forward or backwards
            * Back button to main menu
            * Play From This Point button
        PLAY:
            * Large frame with current stage of game
            * Prompt indicating next player to move
            * Toggle for overlay (if allowed)
            * Zone to input X and Y coordinates of next move
            * Commit Move button.
            * Save
            * undo
            * main menu
        
Tuesday, March 16:
TODO:
    *[DONE] Mock Up of First-Pass Menus
    * [DONE] Program transitions between menus
    ** [] Finish gutting FIAR.py. Last left off on point_bounds section.
    * [DONE] program game-play
    
Mackenzie Feedback:
    * Actually use arrow keys in viewer
    * Back button in Saved game window
    * Show highlighted block in game
    
Wednesday, March 17:
    TODO:
        * [DONE] Get one window to transition.
        * [] Program all transitions
    
    ON WINDOWS AND STATES:
        * The qt ui changes windows by changing an index, though this simply modifies the window being displayed. No real change occur with the program
        * The transition from one window to another may eliminate the need for a state-based user-interface as I had envisioned it previously with subclasses. Because Only certain buttons are available, the user is necessarily placed into a different state, with only certain buttons available.
        * It seems hard to predict what the best way to organize things is right now, so I will just do my best to fail forward.
        ** A state-based approach soudns reasonable for reusing the savedgames screen for both saving and loading. In one state, pressing the save locations has one effect; in another state, there is another effect, but the screen is the same. Maybe displayed text is a bit different too. The state change could
    
    ORDER OF OPERATIONS IN NEWGAME:
        OPTION 1:
            * Click Newgame button
            * Dialogue opens up
            * Dialogue box filled out
            * click "Play"
            * Dialogue triggers MainWindow transition
            * Dialogue sends data to MainWindow and closes.
        OPTION 2:
            * Click NewGame buttin
            * Dialogue opens up
            * click "Play"
            * dialogue saves relevant information internally
            * dilaogue triggers pull of information by MainWindow
            * Main window pulls relevant information, transitions its state, and uses the information.
            * dialogue kills itself
    PvP New Game actions:
    I must now separate the game from the visualization and other aspects
        * Update whose turn is next
        * display the board in the figure window.
        
Thursday, March 18:
    TODO:
        * 
    ON PLOTTING:
        * THe FIAR_Plot.py module will certainly be able to display the game as needed to play it
        * The FIAR_Plot.py module might also be able to display the overlay. Displaying the overlay, however, requires knowing where powers and such are, which is outside the scope of this module.
        * The FIAR_Plot.py module will have functions for plotting powers and such, but they will require locations as inputs from the FIAR_Analysis module.
Friday, March 19:
    TODO:
        ** [DONE] Implement state framework across the board with all states, initialization()s, exit_cleanup()s, to_STATE()s, etc.
        * [Done]Add error handling of improper moves
        * potentially simplify the way in which plotting is done. self.plot.canvas.ax.text() is a bit much.
        * [IGNORE] When saving, rename Main Menu button to Cancel?
        * [DONE] WHen saving, perform the same clean-up as when going to main menu, so that we don't have two figure displaying.
        * [FWD] Create new Dialogue window for resuming a game
            * Next player already decided, but if it is an AI game, then player color must still be chosen.
        
    FIAR_Saves:
        PURPOSE:
            * To handle the saving and loading of games on the saved games window.
        FEATURES:
            * Limits the number of saves
            * Associates each save with a retrieval function
            * Allows for the overwriting of saves
            * Allows for the loading of saves
            * Completed games get removed from the savelist if they ever were there.
        METHODS
    
    SAVING A GAME:
        OPTION 1:
            1. Click "Save"
            2. Get taken to Saves screen in Saving Mode
            3. Saves screen shows all the saves, some of which are labeled as taken and others are not
            4. User clicks on one of the save slots. Clicking on autosave does nothing.
            5. The current game is saved in the appropriate slot
            6. The current game is forgotten
            7. The screen transitions to the mainmenu
            
    STATE TRANSITIONS:
        State transitions follow a pattern:
            * The current state is triggered by some event, such as a button-press to call its to_STATE method.
            * All to_STATE methods have two function calls:
                * self.newstate(STATE)
                * self.initialization()
            * Some to_STATE methods precede those two methods with a call to exit_cleanup()
            * all initializations()s start with a set_frame(FRAME) call and reset the button associations

Monday, March 22:
    TODO:
        * [DONE] Make AI move if it is the first player during initialization.
        * [DONE] save ai color somewhere
        * [DONE] Make window of fixed size
        * [DONE] Hook up save and load buttons
        * [DONE]Select first game in viewer by default
        * [DONE] Cleanup viewer state of FIAR_GUI.py
        * [DONE] Create new Dialogue window for resuming a game
            * Next player already decided, but if it is an AI game, then player color must still be chosen.
        * [IGNORE] Hook up the autosave to trigger for normal exits. Potentially just "main menu"
        * [MEH] Consider rebooting the entire game when returning to the Main Menu. This can help prevent the accumulation of weird state data from all the different combinations of state transitions that are possible. Since eventually, one is very likely to go through the main menu, that is a good place to wipe the slate clean, and potentially cover up any irregularities that add-up; this may be bad practice.
        * [DONE] Get SaveName dialogue box to properly trigger and lead to saving the game.
        * [DONE] Update dialogues to use provided callback functions instead of hard-coded ones.
        * [DONE] modify transition to always use exit_cleanup. When info needs to be saved, copy it before the cleanup and pass it to the new state's intialization method.
        * [MEH] Consider adding "Suggestion" button in PvP and PvAI modes
        
    BUGS:
        * [DONE]first player indicator not updated for PvAI mode
        * [DONE] game and analysis not updated between player move and AI move
        * [DONE] negative integers not allowed in spinboxes for move selection
        * [DONE] Numbers are way too big on the figure, and they appear to stay same size while grid shrinks.
        * [] the spacing indicators are not being drawn on the entire board, just a section of it.
        * [DONE] prints "Performing Loading Initialization" too many times. It is very suspicious.
        * [DONE] "PvP Mode" is still displayed when in PvAI mode
        
    USER AND AI MOVES:
        * In the two-player version, any invalid moves simply have no effect.
        * In the one-player version, user moves are usually followed by AI moves. However, if the user move is invalid, then no AI move should be made. The AI code should execute iff the user move executes wtihout issue. 
    
    Plotting Aspect Ratio Issue:
        * I want the plot to always occupy a square area in the application
        * I want the plot to possibly be rectangular when the layout of the pieces would suggest it
        * I don't want the plot to be stretched in any direction, because that would deform the square grid.
        * I COULD:
            * have rectangular plots be shrunk fit inside the square plotting area without being deformed
            * I could have the plots display extra rows of squares just to maintain a square board. Initially, this seems like it will clutter the board with unneeded squares, but either that space shows blank squares or it shows whitespace.
        
    Responsibilities of ResumeGame dialogue window:
        * A game has already been chosen in whatever MainWindow frame summoned the dialogue window
        * The question is of how the game should be played
        * In the same way that the NewGame process 
        
    HOW WILL ResumeGame Dialogue be used?:
        * In the loading menu, after a save has been selected.
        * In the viewing menu, after "Play Current" has been selected.
        
    What does saving look like?:
        * The user was in the PvP or PvAI Play substates and clicked Save.
        * The user is asked for a savename by dialogue box
        * A state transition is performed to the Saving state, which includes switching to the SavedGame frame.
        * The user clicks on one of the three save locations
        * FIAR_Saves.save_game() is used to save the current game.
        * The user is taken to the Main Menu screen
        
    How to get a savename:
        Option 1:
            * A dialogue pops up with a single text input box and two buttons, "save" and "cancel".
            * If "save" is clicked and there is a valid name, then the dialogue calls a function to finish the saving process.
        Option 2:
            * The save slot itself has a text box appear on top of it or as it, and the user types the name into that.
        Option 3:
            * The name is obtained before the save slot is chosen.
            * Clicking "save" while in the Play frame causes a text box to appear on the frame. This would create another substate.
 
Wednesday, March 24:
    TODO:
        * [DONE] Add recognition of game end
            * [DONE] Add prompt for whether to view game in viewer.
        * [] Improve ease of making moves
            * [] Cursor reset to x-coord spinbox
            * [] Enter recognized in either spinbox as indicating a desire to play the move
            * [] Being able to tab over to and hit enter over any button.
        * [DONE?] Hook up the autosave button for loading.
        * [DONE?] Cause games to autosave
        * [DONE] Unlink buttons upon exiting states
        * [] Clean up the layout of buttons by a combination of fixed sizes and expanding widgets.
        * [] Clean up Viewer class
        * [] Make viewer show overlay for current-ly viewed game.
        
    BUGS:
        * [DONE] Games get saved as csvs but do not persist in Saved games menu after game restart.
        * [DONE] Trying to a load an empty save slot causes an error.
        * [] When resuming a game from the SavedGames menu, one cannot see the board when choosing ai_color.
        * [DONE] Sometimes the SaveName dialogue doesn't close and then tehe save name is doubled in length.("SaveSave")
        * [DONE] Overwritten saves do not get their files deleted
        * [DONE] Can click undo on a game with no moves, switching the play order and causing the marker to be of a negative number.
        * [DONE] Trying to load an empty game crashes the applciation
        * [DONE] Resuming the autosave after a completed game, causes an issue with simulatenously askingto save the "newly completed" game
        * [DONE] A game with one move played in which the AI started can be "undone", and it switches the starting order of the game.
        * [] When the inspected game is switched within the viewer, the state of the overlay toggle is not respected
        * [] The sizes of overlay elements is way too big. There may be a need for scaling them with baord size just like the markers. 
        * [] Create a data structure which tracks powers and threats for each player.
    
    How do games get resumed?
        * MainMenu>Continue>
        * Viewer>Play_Current
    
    How does continuing from Main Menu look lke?
        * Click continue from main menu
            * State transition to (Loading)
        * A save is selected from the options
        * A dialogue window pops up and asks for details about how the game should be played.
        * PvP or PvAI transition occurs
        
    When could autosaving occur?
        * After making a move
        * Upon leaving the PvP or PvAI states, though that seems inferior to after moving.
        
    Victory Involves:
        * Checking for victory after each change
        * IF Victory:
            * Announce Victory and congratulate the victor
            * open a dialogue window to ask the user for a save name
            * If a save name is provided, 
                * then a callback is provided the save name.
                * The callback saves the game
                * Another menu pops up asking whether they would like to view the game in the Viewer
                * The response is provided to a callback that handles the exit from the play screen and potentially the transition to the Viewer.
            * Elif there is no savename:
                * The another menu still pops up and asks if the user would like to view the game
                * The response is provided to a callback that handles the exit from the play screen and potentially the transition to the Viewer.
                
    Opening the current game in Viewer:
        * The current game might not have been saved in records. If not, then the viewer must be passed the game.
        * If the current game has been recorded, then it should be selected from the list. The name is required to select it from te list.
        
    What does programming the OVerlay look like?
        * When the "Overlay Toggle" is checked or unchecked:
            * The flag is appropriately set and  refresh of the display performed
            * If the flag is positive, then a list of PoTs is passed from FIAR_Analysis to FIAR_Plot.
            
    Game Tracker:
        HOW TO STORE DATA?:
            * Maybe two dataframes with time rows and power types for columns?
                * Could combine tables by:
                    * Having an extra column for 'player'
                    * multiindex the rows
            * a list of dictionaries?
        HOW TO GENERATE DATA?
            * Iterate through games
                * feed each game into an analyzer
                * Extract a PoTs count from each analyzer.
                * Morph PoTs count into a dataframe row
                * append df row to the table.
        PROBLEM OF OVERANALYSIS:
            * It would be programmatically simple to (every time a move is made) to feed the current game into the iterating analyzer and get the full dataframe for each step. However, this would involve recalculating known quantities every single time a move is made; every previous power count would not change.
            * It would be computationally preferred to, when a new move is made, to add the new power counts to the existing dataframe.
            * Regardless of whether an optimization is performed as described above, the ability to generate a full history from a single game is still neccessary, and that will be used until no longer convenient.
        
        THOUGHTS:
            * The Viewer and analysis are getting more and more complex.
            * I am butting up against similar strcutural limitations of these two sections as before
            * I hope to expand the capability of both before I am done
            * A large rework of the viewer and the Analyzer, and the plotter will be neccessary.
            * At the very least, wtih current capability, my code must be made more comprehensible.
            
Thursday, March 25:
    TODO
        * [] Fix visualization of powers and threats
            * [] Make sure that toggle overlay's state is always considered when changing viewing index or changing the game.
            * [] markers scale with plot size
        * [] Create several compatible game_history visualizations and play with them.
        * [DONE] Change plotting style to be more step-wise
        * [DONE] FIX MY BROKEN-ASS ENVIRONMENT
        * [DONE] Get any audio play
        
        
    STEPPIFYING A DATAFRAME:
        * Stepping through the old dataframe, a new one can be created by modifying and appending.
        
Friday, March 26:
    TODOS:
        * [] Add audio to the game
        * [DONE] Get Sasha to test the game for me.
        * [] Improve the AI by having it recognize overlapping power triggers
        * [] Incorporate some kind of summary information for users of the Viewer, like a plot or table
        * [] Clean up the git repository and make it presentable.
        * [] Add proper labels to buttons and background images to pop-up elements
        * [] Delete the options button.
        * [DONE] Add ability to surrender
            * [DONE] Surrender Button
        * [] Store metadata about played games
        * [] Fix issue of having to reset viewer toggle when stepping through game
        * [] Make buttons appear clickable, maybe
        * [] Make the viewer save the view location for a game when switching to another game. This would allow switching between two different games in two different game states for comparison.
        * [] Add game metadata in the viewer:
            * Date played
            * Players
            * Mode
            * Showing Move x of y

    SOUNDS:
        * [] Set up multithreading for background music
        * [] Include differentiation between victory and defeat
        * [] Modify exit and cancel buttons to perform their functions outside of Qt DEsigner so that a click sound can be attached
        * [?] Decide whether "end" sound means anything
        * [] Pick out music that you like. 
    LAYOUT:
        * [DONE] Rearrange Buttons for new frame shape and size
        * [DONE] Vertical Play arrangement
        * [DONE] Surrender utton
        * [DONE] get rid of Move garbage.
    YOU'RE BACK:
        * 
        
    BUGS:
        * [] The game grid gets chopped off on the bottom. 40 pixels are lost in the frame. probably a qt designer layout issue.
        * [DONE] The viewer index gets reset each time the user toggles the Overlay.
        * [DONE] The ability to view a game in the viewer that is not a saved record is fucking with my ability to toggle the overlay. I will remove the ability to view unrecorded games in the viewer.
        * [] I can save games with a name that is then impossible to load, like "A    B".

Friday April 30th:
    Broad TODO:
        * Finish FIAR
        * Wrap FIAR up in an executable
        * Post on LinkedIn 
    * Specific ToDos will be visible above.
    
Tuesday May 4:
    Info Screens to help Players:
        * Info screens show up for the first time and after that only if the question mark is clicked.
        * There could be a help button on the main menu or in the play area. Clicking it opens a separate window that shows:
            * The goal is to get Five In A Row, hence the name
            * All pieces of one color are identical. The numbering is intended to help keep track of the game's history.
            * Moves can be undone
            * Surrender is an option
            * Saving is an option
        * A help button on the Viewer screen should show:
            Here lie all recorded games played to completion, and they can be selected by clicking on their names.
            Backwards and Forwards allow you to step through a game, see it unfold, and perhaps realize where a fatal mistake was made.
            Toggling the Overlay will highlight certain patterns that show up in all games.
            If you find a game that you want to replay, just step to the right state and click Play Current.
            Define:
                * Hard Threat
                    * Defusers
                * Soft Threat
                * Hard Power
                    * Triggers
                * Soft Power
                * 
    Saving the view index for each viewed game when navigating the viewer.
        * The view indices are stored in a dictionary{name: view index}.
        * Upon entering the Viewing State, a new view index value is created for the most recent frame
        * When switching games, the view index is looked up
        * When moving forward backwards in a game, the view index is updated
