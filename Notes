Thoughts, Monday Feb 8:
    * The game appears to be workable but needs some work.
    * First, it must be made more usable for human play through a terminal.
    * Secondly, we must create the capability to look at a game digitally, scanning along runs, and columns and such.
    TODO:
        * Add the ability to check if a given location has already been taken by a move(or what color it is)
        * Prevent players from placing moves where there already are some.
        * [DONE] Add ability to undo a move.
        * Add terminal interface to the game.
        * [DONE] Create a testing script that generates a game and runs through some moves.

Wednesday, Feb 10:
    TODO:
        * [DONE] Add ability to check if move is taken
        * [DONE]prevent players from making illegal moves
        * [DONE]Add automatic expansion of the game board
        * [DONE] add terminal interface
        * [DONE] Add handling of exceptions to terminal interface for situations like:
            * point off board
            * repeat point
            * non-int value
        * [] Update the demo notebook to showcase the game's capabilities
        * [FWD] Recognition of the game's end.
        * [] Tidy the repository, deleting random shit.
    POTENTIAL TODOS:
        * add scaling of the numbers to the size of the board so that how they look within the squares does not change.
        * add documentation to the code.
    On the expansion of the board:
        *[NOT DOING] It could be that the width and height of the board increases as neccessary and the aspect ratio is modified to maintain a square grid. This requires recognizing when a move is within n of the edge. Since most games usually approach one edge and not the opposite edge simulatenously, this would likely generate many squares that we don't even need.
        * [DONE] An alternative is to first redefine how the grid size is defined to not be inherently symmetrical across the x and y axes. This would allow us to expand just a single edge when needed and lead to better-looking games.
    How to recognize that a move is within two of the edge?:
        * The x (or y) coordinate would be more than the edge location-2. This could trigger the expansion of the boundary by one. 
        * The minimum distance to an edge can be calculated, and then that used to expand the border by n-spaces.
    On expanding the board:
        * Increasing the value for self.right_edge or any of the others would result in correctly drawing additional squares and gridlines. It would also increase the area in which moves are allowed. It would also modify the aspect ratio to maintain a square grid. The only missing piece seems to properly refresh the image displayed to the user.

Thursday, Feb 11:
    TODO:
        * [DONE] Transform game df data into matrix
        * [DONE] Scan columns and rows of matrix to fill queue
        * [DONE] Match patterns to queue contents to recognize end of game.
        * [DONE] Diagonal scanning
        * [DONE] incorporate end-of-game notice into playable game.
        * [] Consider different coordinate systems of game and matrices and its impact.
        * [DONE] Create helper functions for transforming game coordinates to matrix indices and vice versa.
        * [DONE] Come up with ways to mark board that makes it easier to place the move.
        
    THOUGHTS:
        * The next step seems to try and recognize patterns other than victory. Measuring and tracking soft and hard powers and threats could be a nice way to visualize a game.
        * It could be cool to have a mode where the recognized patterns are annotated directly on the plot. This would make debugging pattern detection much easier. Maybe just start with drawing a line over the winning series of moves. This could be done in a debug mode for starters. A notation that could be manually replicated owuld allow for comparison between us and the computer.
        * Adding methods like to_csv() and from_csv() would be good practice for other sitautions in which data is to be saved or loaded. It would also allow for the storage of games, making playing on the computer not imply that the game will be created and lost forever. These saved games would likely just be visualized, so some helper method for that would be good. Saving a game and playing it later would be good too; Maybe have a set number of games that can be saved, ask people for names to them, and display them like some sort of arcade game.

Friday, Feb 12:
    THOUGHTS:
        * It will be neccessary when working on pattern recognition to understand what is being recognized and where. Since it is not entirely clear even how we think about soft and hard powers and threats, the computer will certainly be a bit confused.
        * The terminology of soft and hard powers and threats is useful but may be insufficient. In the simple case of the eeexxeee arrangement, there is a single soft power and yet four possible, mutually-exclusive locations that would turn it into a soft threat. The terminology of soft and hard powers and threats refers to existing pieces and blanks, but does not talk about the locations where the new move would go.
        * New terms:
            *Soft Trigger: A location where, if a marker is placed, a soft power is transformed into a soft threat.
            *Hard Trigger: A location where, if a marker is placed, a hard power is trasnformed into a hard threat.
            
            Soft and Hard Triggers can coexist in a single tile, as is usually done to achieve a victory.
        
        
Saturday, Feb 13:
    THOUGHTS:
        * Could add step-through viewer for games, so that you can click the arrow keys to go forward and back. This would require a to_csv and from_csv-type methods that would allow saving and loading games. We would also need some sort of interface for interacting with the save files and displaying them. 
        * A library of games that allows you to step through them sounds pretty cool. Maybe even allow comments. Annotations should be optional to turn on or off. Stats displayed about the current slide and other slides as well, such as number of soft and hard power/threats for each player. Maybe a line graph where the past is filled-in and the future is alpha~=0.5.
        * The option to play a recorded game from a certain move is essential.
        * The ability to recognize similarities between games would be very cool. Might be difficult to recognize two games that are different but effectively identical, such as rotated games, transposed games, and reflected games. Games that were branches of other games should at least be recognizable as branches.
        * Add description of the game at launch, including victory condition and optional inputs
        * Maybe add an actual UI with buttons and shit.
        * It could be good to look into detecting key presses instaed of just text inputs.
        * Scaling the displayed numbers for the size of the grid could be nice.
        
        
Monday, Feb 15:
    THOUGHTS:
        * What are the benefits of tracking powers, threats, and triggers?:
            * The relative abosulte number of soft or hard powers between players might give an estimate of who is doing better.
            * The ratio of soft or hard powers to the number of moves made could give an estimate of how "tied up" or "free" someone's pieces are.
        * What are the benefits of tracking threats?:
            * The existence of a threat from the enemy is important to notice in order to properly react.
            * Unexpected victories usually come as a result of several moves which both trigger and generate power. The last move is usally in a location that is a trigger for multiple locations.
        * What are the benefits of tracking triggers?:
            * Two triggers in the same place indicate a location that will likely cause victory.
            * Triggers show us where we can go to force the enemy to make a move. Predicting where the enemy will go is already difficult for a person, and is inherently unpredictable.
        * What do we call the locations that you can place a move to prevent a threat from ending the game?
            * In the case of hard threats, there is usually only one place to go.
            * In the case of soft threats, there are usually a few options that allow you to block.
            * Any hard trigger is also an effective location for preventing a loss due to an enemy soft threat.
        * What metadata could each game have attached to it?
            * The names of the players and their colors
            * The name of the game itself. Could be autogenerated from the names and DateTime.
            * The date and time of the game.
        * What currently needs to be saved for a game?
            * The df
        * What needs to be recalculated after loading a game?
            * The location of the games edges
            * The game matrix
        
    TODO:
        * [DONE] Add Description of game at launch, including special character inputs
        * [DONE] Add to_csv, from_csv methods.
        * [DONE] Modify __init__ method to take an existing df.
        * [FWD] add detection of saved games
        * [DONE] add option to load a saved game or start a new one.
        * [FWD] Add comments to stuff
        * [] ? Add testing of loading and saving games
        * [FWD] implement autosave in case the game crashes.
        * [] option to save game image
        
        
    QUESTIONS:
        * Why does the use of exit() to end a game cause a SystemExit exception? Because that is literally all it is meant to do. The answer is to handle the exception at the highest level of your code, allowing you to gracefully exit from any point in your code. The use of os._exit(1) during the exception handling is an option to completely kill your program; in my experience seems to kill the kernel.
        
    IMPORTANT:
        * The game currently gets stuck trying to load a game after a save is performed. This could likely be helped by being able to check whether the specified filename is in the saves folder. If it is, then we can continue out of the input loop and simply load the game. This requires me to be able to list the contents of the saves folder.
        
Tuesday, Feb 16:
    TODO:
        * [DONE] Handle SystemExit exception
        * [DONE] add detection of saved games
        * [DONE] Fix issue of trying to load a game after playing a loaded game.
        * [DONE] Extract the selection of saves
        * [DONE] Create the game viewer.
        * [FWD] Add option to save and continue instead of just leaving

      
    * I think now that we have a viewer, it is a great time to implement the annotation for powers, threats, and triggers. The viewer (in a debug mode, potentially), will allow us to easily see how annotation generation is going.  
        
    Creating a step-through viewer for games:
        * Would be a third option alongside new game and loading.
        * Would load in a game as input
        * would listen to keyboard clicks for input
        * For each press, it essentially pretends that only a subset of the data exists and draws that.
        * A forward press increases the length of the data table
        * A backwards press reduces the length of the data table.
        * The enter key allows the user to start playing a new game from that point, with a double-check
        
    Should the viewer simply be built-in as part of playing a new or loaded game?:
        * Maybe later
        
    How to implement a viewer:
        * The game could have a view index which is normally set to "last" which determines location up to which information is displayed. For example, if a game that has gone for 10 moves has a view_index of 5, then retrieving the dataframe or displaying the markers will only show the first 5 moves. This would conflict with other properties, like the game board edges, which is something that gets calculated from the most recent DataFrame.
        * Passing the first n_rows of a game's dataframe into the game constructor would have the desired result. It then becomes a matter of keeping track of the index which we are interested in.
        
        
Wednesday, Feb 17:
    TODO:
        * [DONE] Add option to save and continue instead of just leaving
        * [DONE] Autosave
        * [DONE] Tell the user if a file already exists when saving
        * [DONE] Implement ability to play viewed game from the state that it is currently in.
        * [DONE] Replace some code with Input Handler for cleanliness
        * [DONE] Look into setting the size of the plot to be proportional to the number of squares in each dimension. This would prevent the displayed size of the pieces changing with the size of the board.
        * [DONE] simplify game loop
        * [PAUSED] choose some convention for how to count powers, threats, and triggers. 
        * [] Add comments to stuff. Forces me to reinterpret and reevaluate existing code. 
        * [] Adopt MITOCW testing framework
        * [] Look into testing which involves interacting with the terminal.
        * [PAUSE] Allow '.' to separate move coordinates
        * [] limit number of saves in saves folder.
        * [] restructure scanning code
        * [DONE] Save completed games to records folder
        * [CANCELED] reorganize how different directions of scans have repeating code.
        * [DONE] compartmentalize the process of determining the save location, including asking about overwriting.
        * [] Reassess categorization of class and static methods
        * [] Add HP detection
        * [] Add SP and HP visualization
        * [] decide what to do about 'eefeffeee' being detected as a soft power with triggers in the -2 and -3 positions. Maybe check SP locations against HP locations to eliminate incorrect SPs. Maybe check for HPs first, and prevent creation of that SP.
        * [] More-thoroughly test SP detection in different directions.
        * [] Add calcaulation of powers and threats for games created from existing dfs.
        * [] Create method that takes in a game and generates a game for each step in that game. The powers and threats in the game will then be aggregated and plotted.
        * []Add checking of ST and HT lists during creation of SPs and HPs. What about checking for HTs during ST generation? To do that, we would need to loop through the queue's yet again. We must also make sure that SPs are superceded by HPs. We need to loop through the queues 4 times to check for, in this order, HTs, STs, HPs, SPs, with each subsequent group checking if any match's markers are a subset of a match from a higher-order group.
    
    THOUGHTS:
        * There are still many things to clear up about how to store information about strong and weak powers, threats, triggers. These must be worked out on paper before any digitization makes sense.
        * I am getting to a point in the decision tree of my main game loop that some diverging paths converge again. The simplest solution to me seems to package any locations where paths converge as its own function, and just use that in both places in the tree. This could result in many unimportant functions, but it's all I got.
        * I process many simple inputs from the user, and it takes up a lot of lines of code with its while loop and shit like that. Maybe I can create some general input handler for simple cases.
        * There is an issue with double-counting sets of markers as both threats and powers. The solution i will try is to calculate threats first. If a power is detected and all of its markers belong to a single threat, then that will not be considered a power. This would prevent 'eefeffeee' from being considered both a SP and ST, which is good. This would also prevent 'eefffee' from being considered a hard power, which i am unsure about. We'll see.
        
    SIMPLE INPUT HANDLER:
        * A common case for handling inputs is a many-to-few case, where the user can input anything from a few lists. Any input that is included in any of the lists will case the output of a flag value indicating which bin was satisfied. Failure to provide a response within any of the categories elicits a prompt to the user. The flag value is used downstream of the input handling to determine what actions are performed. Since the performed actions can be quite complex and involve any variables from outside the input-handling context, the performed actions will not be supplied as inputs to the input handler.
        CASES THAT ARE NOT EASILY-COVERED:
            *When the input is checked for special values, and if all of those checks fail, the input is passed onwards.
            * When complex input verification is necessary, like whether something is an integer or passes a certain function. I suppose that the valid list of options for each output possibility could be replaced with a function that takes the user-supplied-input and returns True or False. The input_handler could check whether it was supplied a list or a function.
            * We currently check if the user input falls into a category. It also nice to check if some constant is contained within the user input, like a '.'
        
    REMINDER:
        * Just added processing of SP patterns. Not tested.
        * Next is to compare these patterns to the scanned queues and add the results some list of powers and triggers
        * The scanning will lkely need to be modified to reduce the repetition of code.
        * 
        
    
        LESSON: Hide as much input handling code as possibled. What we care about is the final decision, no matter how circuituous the path. Example, FIAR.save_name_input().
        
    STATIC vs CLASS METHODS:
        * Static methods should not modify the class object if they are handed one.
        * 
    
    Thoughts on combining the different scanning methods:
        * Each scanning method can be defined as a set of starting points from which you go a certain distance in a certain direction. This direction is the opposite of the tail direction, which we need to calculate marker and trigger locations when pattern matches are found.
    
    Thoughts on heirarchy of recognition for powers and threats:
        * One way to prevent double-counting of markers as soft and hard powers and threats is to loop through the queues 4 times.
        * Another way is to first generate all of the different powers and threats, only making sure that any equals within the groups are lumped together. Then we can systematically step through all of the STs and compare them to HTs. Then compare all of the HPs to the HTs and STs. Then compare all of the SPs to the HTs, STs, and HPs. This eliminates the need to loop 4 times through the queues.
Saturday, Feb 20th:
    TODO:
        * Reorganize code to allow for better scanning
        
    THOUGHTS:
        * It could be useful to look at the section in the Python Cookbook on data processing pipelines, since that is essentially what I am trying to do.
    THOUGHTS on Restructuring of scanning:
        * Parts:
            * Generate list of starting points for each scanning method
            * For each set of starting points, build your queues in a certain direction.
            * Perhaps this code spills out queues, their head locations, and tail directions.
            * These queues are scanned for powers and threats and recorded
            * The lists of powers and threats are scanned through again and collapsed within their individual categories. This would be most efficient in the context of a particular scanning direction.
            * The powers and threats are examined in heirarchical order to eliminate double-counts.
            
        * Do we need both a queue of len6 and queue of len5?
            * queue5 will always be the front 5 elements of queue6. The receiver of queues from queue_scan could just make queue5 on the spot.
        
        * If the code matching patterns to queues isn't concerned with overlapping powers then does it need to know the head_loc and tail_dir? I think not. it can just return a matching pattern.
            
    LESSON:
        * If you think the problem ahead is a bit unclear, even if you aren't willing to admit that it will be "hard", start with the documentation for individual functions. This will verify if the pieces as you imagine them fit together, clarify your goals when you are actually writing code, and is something that you'll have to do at some point anyway. If you wait to document until after you've written your code, you will find holes in your code that would not otherwise have been there, and you will not remember what everything does. Writing code in un-spec'd functions is a great way to muddy the scope of a function and to start writing unmodular code.
        * Always create your testing framework before coding anything. It is your eyes, and without it you are blind.


Tuesday, Feb 23:
    TODO:
        * 
        
    THOUGHTS:
        * There are likely many places where the use of generators would be beneficial.
        * I have hidden away the ugly generation of queues, but now I want access to the moments at which we switch rows to clear some memory. I could capture the switch from one row to another in the values that are returned by queues(), such as by structuring the queues in a nested data structure where it goes direction[starting_loc[queues[]]]
        
    SCANNING:
        * generate list of lists of lists of queues
        * unpack list of lists of lists of queues while matching patterns
        * Matched patterns for each category are compared heirarchically and repeats eliminated.
        
    We either go through all queues 4 times in order of the heirarchy of powers/threats and compare all new matches with the existsing ones in the same line of scanning OR we go through the queues once, generating overlapping powers and threats, and then clean them up later. It would be difficult to clean up the matches and eliminate repeated ones without knowing which pattern matches line up with each other.
    
    We could have a master list of PoTs. Each category of power or threat is run through and compared/added to the master list. Repeats are eliminated.
    
    PROBLEM:
        * By nesting my queues within their respective contexts of scanning direction and starting location, i was forced to generate a list of all the queues, which is very memory-intensive. Modifying the queue_gen to generate queues on demand but still in a layered format would be excellent, though potentially difficult. Could use some tips from the pipeline example.
        
Wednesday, Feb 24:
    TODO:
        * [DONE] Complete detection of all powers and threats
        * [DONE] Visualize Hard and soft powers and add it to the viewer
        * [] Reintroduce ending the game upon victory
        * [DONE] Add option to view record games
        * [DONE] Add some nice formatting to the terminal interface
        * [FWD] Switch to the viewer once a game has been completed
        * [FWD] Properly handle key.char lacking attributeError
    MAYBE TODO:
        * Make visualization of hard and soft powers toggleable
        * Store PoTs in a df.
        * Create some tests for PoT detection.
        * Extracting and plot PoTs for a game over time. Maybe lines
        * Generalize marker plotting function to draw both numbers and PoT markers
    DRAWING PoTs:
        Soft Powers:
            * Draw marker on trigger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Hard Powers:
            * Draw marker on triger locations
            * Calculate two extreme marker or trigger locations
            * Draw line between extreme marker or trigger locations
        Soft Threats: 
            * Find any gaps between marker locations
            * Shade marker locations and gaps in grey or red
        Hard Threats:
            * Find any gaps between marker locations
            * Shade marker locations in darker grey or red.
            
    THOUGHTS:
        * We may want to not have Soft Threats eliminate overlapping hardpowers when detecting PoTs. This could be achieved by cmparing STs and HPs to the HTs list independenty, and then combinging all three. SPs would then have to be compared to the combined list and added.

Thursday, Feb 25:
    TODO:
        * [] Properly handle key.char lacking attributeError
        * [DONE] Switch to the viewer once a game has been completed 
        * [DONE] Reintroduce ending the game upon victory
        * [DONE] If "None" provided for save name, no save made
        * []
    TODO CANDIDATES:
        * [] Add way to extract summary statistics on a game and display them
        * [] Add option to have PoT overlay on during regular gameplay
        * [] Add way to 
    BUGS:
        * [DONE] "Black victory detected" when last move made in viewer
        * [DONE] You can load a game that has already been won, have it ask for a move, and then say the game is over after the move is made no matter what. Instead, it would be preferrable if a game is checked for victory upon loading
        * [IGNORE] When you load a game that has been won already, the victory is immediately noticed and play ceases, but the user is still asked if they would like to save it. Whatever; they can just not save it if they like.
        
    PUT OFF:
        * [] Investigate the "AttributeError: module 'FIAR' has no attribute 'FIAR'" problem
        * [] Indicate in the viewer what step you are at.
        * [] Investigate the creation of too many figures when drawing markers.
        
    Terminal Interface Testing:
        * Instead of listened to, the keyboard can be emulated, and this can allow us to test the terminal interface.
